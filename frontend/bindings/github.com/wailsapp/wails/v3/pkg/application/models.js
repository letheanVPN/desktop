// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as u$0 from "../../../../../leaanthony/u/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as events$0 from "../events/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as slog$0 from "../../../../../../log/slog/models.js";

export class App {
    /**
     * Creates a new App instance.
     * @param {Partial<App>} [$$source = {}] - The source object to create the App.
     */
    constructor($$source = {}) {
        if (!("Window" in $$source)) {
            /**
             * Manager pattern for organized API
             * @member
             * @type {WindowManager | null}
             */
            this["Window"] = null;
        }
        if (!("ContextMenu" in $$source)) {
            /**
             * @member
             * @type {ContextMenuManager | null}
             */
            this["ContextMenu"] = null;
        }
        if (!("KeyBinding" in $$source)) {
            /**
             * @member
             * @type {KeyBindingManager | null}
             */
            this["KeyBinding"] = null;
        }
        if (!("Browser" in $$source)) {
            /**
             * @member
             * @type {BrowserManager | null}
             */
            this["Browser"] = null;
        }
        if (!("Env" in $$source)) {
            /**
             * @member
             * @type {EnvironmentManager | null}
             */
            this["Env"] = null;
        }
        if (!("Dialog" in $$source)) {
            /**
             * @member
             * @type {DialogManager | null}
             */
            this["Dialog"] = null;
        }
        if (!("Event" in $$source)) {
            /**
             * @member
             * @type {EventManager | null}
             */
            this["Event"] = null;
        }
        if (!("Menu" in $$source)) {
            /**
             * @member
             * @type {MenuManager | null}
             */
            this["Menu"] = null;
        }
        if (!("Screen" in $$source)) {
            /**
             * @member
             * @type {ScreenManager | null}
             */
            this["Screen"] = null;
        }
        if (!("Clipboard" in $$source)) {
            /**
             * @member
             * @type {ClipboardManager | null}
             */
            this["Clipboard"] = null;
        }
        if (!("SystemTray" in $$source)) {
            /**
             * @member
             * @type {SystemTrayManager | null}
             */
            this["SystemTray"] = null;
        }
        if (!("Logger" in $$source)) {
            /**
             * @member
             * @type {slog$0.Logger | null}
             */
            this["Logger"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new App instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {App}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType1;
        const $$createField1_0 = $$createType3;
        const $$createField2_0 = $$createType5;
        const $$createField3_0 = $$createType7;
        const $$createField4_0 = $$createType9;
        const $$createField5_0 = $$createType11;
        const $$createField6_0 = $$createType13;
        const $$createField7_0 = $$createType15;
        const $$createField8_0 = $$createType17;
        const $$createField9_0 = $$createType19;
        const $$createField10_0 = $$createType21;
        const $$createField11_0 = $$createType23;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Window" in $$parsedSource) {
            $$parsedSource["Window"] = $$createField0_0($$parsedSource["Window"]);
        }
        if ("ContextMenu" in $$parsedSource) {
            $$parsedSource["ContextMenu"] = $$createField1_0($$parsedSource["ContextMenu"]);
        }
        if ("KeyBinding" in $$parsedSource) {
            $$parsedSource["KeyBinding"] = $$createField2_0($$parsedSource["KeyBinding"]);
        }
        if ("Browser" in $$parsedSource) {
            $$parsedSource["Browser"] = $$createField3_0($$parsedSource["Browser"]);
        }
        if ("Env" in $$parsedSource) {
            $$parsedSource["Env"] = $$createField4_0($$parsedSource["Env"]);
        }
        if ("Dialog" in $$parsedSource) {
            $$parsedSource["Dialog"] = $$createField5_0($$parsedSource["Dialog"]);
        }
        if ("Event" in $$parsedSource) {
            $$parsedSource["Event"] = $$createField6_0($$parsedSource["Event"]);
        }
        if ("Menu" in $$parsedSource) {
            $$parsedSource["Menu"] = $$createField7_0($$parsedSource["Menu"]);
        }
        if ("Screen" in $$parsedSource) {
            $$parsedSource["Screen"] = $$createField8_0($$parsedSource["Screen"]);
        }
        if ("Clipboard" in $$parsedSource) {
            $$parsedSource["Clipboard"] = $$createField9_0($$parsedSource["Clipboard"]);
        }
        if ("SystemTray" in $$parsedSource) {
            $$parsedSource["SystemTray"] = $$createField10_0($$parsedSource["SystemTray"]);
        }
        if ("Logger" in $$parsedSource) {
            $$parsedSource["Logger"] = $$createField11_0($$parsedSource["Logger"]);
        }
        return new App(/** @type {Partial<App>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {number}
 */
export const BackdropType = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    Auto: 0,
    None: 1,
    Mica: 2,
    Acrylic: 3,
    Tabbed: 4,
};

/**
 * @readonly
 * @enum {number}
 */
export const BackgroundType = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    BackgroundTypeSolid: 0,
    BackgroundTypeTransparent: 1,
    BackgroundTypeTranslucent: 2,
};

/**
 * BrowserManager manages browser-related operations
 */
export class BrowserManager {
    /**
     * Creates a new BrowserManager instance.
     * @param {Partial<BrowserManager>} [$$source = {}] - The source object to create the BrowserManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new BrowserManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {BrowserManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new BrowserManager(/** @type {Partial<BrowserManager>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {number}
 */
export const ButtonState = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    ButtonEnabled: 0,
    ButtonDisabled: 1,
    ButtonHidden: 2,
};

/**
 * ClipboardManager manages clipboard operations
 */
export class ClipboardManager {
    /**
     * Creates a new ClipboardManager instance.
     * @param {Partial<ClipboardManager>} [$$source = {}] - The source object to create the ClipboardManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClipboardManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ClipboardManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ClipboardManager(/** @type {Partial<ClipboardManager>} */($$parsedSource));
    }
}

/**
 * ContextMenuManager manages all context menu operations
 */
export class ContextMenuManager {
    /**
     * Creates a new ContextMenuManager instance.
     * @param {Partial<ContextMenuManager>} [$$source = {}] - The source object to create the ContextMenuManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ContextMenuManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ContextMenuManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ContextMenuManager(/** @type {Partial<ContextMenuManager>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {number}
 */
export const CoreWebView2PermissionState = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    CoreWebView2PermissionStateDefault: 0,
    CoreWebView2PermissionStateAllow: 1,
    CoreWebView2PermissionStateDeny: 2,
};

/**
 * DialogManager manages dialog-related operations
 */
export class DialogManager {
    /**
     * Creates a new DialogManager instance.
     * @param {Partial<DialogManager>} [$$source = {}] - The source object to create the DialogManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new DialogManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {DialogManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new DialogManager(/** @type {Partial<DialogManager>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {number}
 */
export const DragEffect = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * DragEffectNone is used to indicate that the drop target cannot accept the data.
     */
    DragEffectNone: 1,

    /**
     * DragEffectCopy is used to indicate that the data is copied to the drop target.
     */
    DragEffectCopy: 2,

    /**
     * DragEffectMove is used to indicate that the data is removed from the drag source.
     */
    DragEffectMove: 3,

    /**
     * DragEffectLink is used to indicate that a link to the original data is established.
     */
    DragEffectLink: 4,
};

/**
 * EnvironmentManager manages environment-related operations
 */
export class EnvironmentManager {
    /**
     * Creates a new EnvironmentManager instance.
     * @param {Partial<EnvironmentManager>} [$$source = {}] - The source object to create the EnvironmentManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new EnvironmentManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {EnvironmentManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new EnvironmentManager(/** @type {Partial<EnvironmentManager>} */($$parsedSource));
    }
}

/**
 * EventManager manages event-related operations
 */
export class EventManager {
    /**
     * Creates a new EventManager instance.
     * @param {Partial<EventManager>} [$$source = {}] - The source object to create the EventManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new EventManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {EventManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new EventManager(/** @type {Partial<EventManager>} */($$parsedSource));
    }
}

/**
 * KeyBindingManager manages all key binding operations
 */
export class KeyBindingManager {
    /**
     * Creates a new KeyBindingManager instance.
     * @param {Partial<KeyBindingManager>} [$$source = {}] - The source object to create the KeyBindingManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new KeyBindingManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {KeyBindingManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new KeyBindingManager(/** @type {Partial<KeyBindingManager>} */($$parsedSource));
    }
}

/**
 * LinuxWindow specific to Linux windows
 */
export class LinuxWindow {
    /**
     * Creates a new LinuxWindow instance.
     * @param {Partial<LinuxWindow>} [$$source = {}] - The source object to create the LinuxWindow.
     */
    constructor($$source = {}) {
        if (!("Icon" in $$source)) {
            /**
             * Icon Sets up the icon representing the window. This icon is used when the window is minimized
             * (also known as iconified).
             * @member
             * @type {string}
             */
            this["Icon"] = "";
        }
        if (!("WindowIsTranslucent" in $$source)) {
            /**
             * WindowIsTranslucent sets the window's background to transparent when enabled.
             * @member
             * @type {boolean}
             */
            this["WindowIsTranslucent"] = false;
        }
        if (!("WebviewGpuPolicy" in $$source)) {
            /**
             * WebviewGpuPolicy used for determining the hardware acceleration policy for the webview.
             *   - WebviewGpuPolicyAlways
             *   - WebviewGpuPolicyOnDemand
             *   - WebviewGpuPolicyNever
             * 
             * Due to https://github.com/wailsapp/wails/issues/2977, if options.Linux is nil
             * in the call to wails.Run(), WebviewGpuPolicy is set by default to WebviewGpuPolicyNever.
             * Client code may override this behavior by passing a non-nil Options and set
             * WebviewGpuPolicy as needed.
             * @member
             * @type {WebviewGpuPolicy}
             */
            this["WebviewGpuPolicy"] = WebviewGpuPolicy.$zero;
        }
        if (!("WindowDidMoveDebounceMS" in $$source)) {
            /**
             * WindowDidMoveDebounceMS is the debounce time in milliseconds for the WindowDidMove event
             * @member
             * @type {number}
             */
            this["WindowDidMoveDebounceMS"] = 0;
        }
        if (!("Menu" in $$source)) {
            /**
             * Menu is the window's menu
             * @member
             * @type {Menu | null}
             */
            this["Menu"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new LinuxWindow instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {LinuxWindow}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $Create.ByteSlice;
        const $$createField4_0 = $$createType25;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Icon" in $$parsedSource) {
            $$parsedSource["Icon"] = $$createField0_0($$parsedSource["Icon"]);
        }
        if ("Menu" in $$parsedSource) {
            $$parsedSource["Menu"] = $$createField4_0($$parsedSource["Menu"]);
        }
        return new LinuxWindow(/** @type {Partial<LinuxWindow>} */($$parsedSource));
    }
}

/**
 * MacAppearanceType is a type of Appearance for Cocoa windows
 * @readonly
 * @enum {string}
 */
export const MacAppearanceType = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: "",

    /**
     * DefaultAppearance uses the default system value
     */
    DefaultAppearance: "",

    /**
     * NSAppearanceNameAqua - The standard light system appearance.
     */
    NSAppearanceNameAqua: "NSAppearanceNameAqua",

    /**
     * NSAppearanceNameDarkAqua - The standard dark system appearance.
     */
    NSAppearanceNameDarkAqua: "NSAppearanceNameDarkAqua",

    /**
     * NSAppearanceNameVibrantLight - The light vibrant appearance
     */
    NSAppearanceNameVibrantLight: "NSAppearanceNameVibrantLight",

    /**
     * NSAppearanceNameAccessibilityHighContrastAqua - A high-contrast version of the standard light system appearance.
     */
    NSAppearanceNameAccessibilityHighContrastAqua: "NSAppearanceNameAccessibilityHighContrastAqua",

    /**
     * NSAppearanceNameAccessibilityHighContrastDarkAqua - A high-contrast version of the standard dark system appearance.
     */
    NSAppearanceNameAccessibilityHighContrastDarkAqua: "NSAppearanceNameAccessibilityHighContrastDarkAqua",

    /**
     * NSAppearanceNameAccessibilityHighContrastVibrantLight - A high-contrast version of the light vibrant appearance.
     */
    NSAppearanceNameAccessibilityHighContrastVibrantLight: "NSAppearanceNameAccessibilityHighContrastVibrantLight",

    /**
     * NSAppearanceNameAccessibilityHighContrastVibrantDark - A high-contrast version of the dark vibrant appearance.
     */
    NSAppearanceNameAccessibilityHighContrastVibrantDark: "NSAppearanceNameAccessibilityHighContrastVibrantDark",
};

/**
 * MacBackdrop is the backdrop type for macOS
 * @readonly
 * @enum {number}
 */
export const MacBackdrop = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * MacBackdropNormal - The default value. The window will have a normal opaque background.
     */
    MacBackdropNormal: 0,

    /**
     * MacBackdropTransparent - The window will have a transparent background, with the content underneath it being visible
     */
    MacBackdropTransparent: 1,

    /**
     * MacBackdropTranslucent - The window will have a translucent background, with the content underneath it being "fuzzy" or "frosted"
     */
    MacBackdropTranslucent: 2,

    /**
     * MacBackdropLiquidGlass - The window will use Apple's Liquid Glass effect (macOS 15.0+ with fallback to translucent)
     */
    MacBackdropLiquidGlass: 3,
};

/**
 * MacLiquidGlass contains configuration for the Liquid Glass effect
 */
export class MacLiquidGlass {
    /**
     * Creates a new MacLiquidGlass instance.
     * @param {Partial<MacLiquidGlass>} [$$source = {}] - The source object to create the MacLiquidGlass.
     */
    constructor($$source = {}) {
        if (!("Style" in $$source)) {
            /**
             * Style of the glass effect
             * @member
             * @type {MacLiquidGlassStyle}
             */
            this["Style"] = MacLiquidGlassStyle.$zero;
        }
        if (!("Material" in $$source)) {
            /**
             * Material to use for NSVisualEffectView (when NSGlassEffectView is not available)
             * Set to NSVisualEffectMaterialAuto to use automatic selection based on Style
             * @member
             * @type {NSVisualEffectMaterial}
             */
            this["Material"] = NSVisualEffectMaterial.$zero;
        }
        if (!("CornerRadius" in $$source)) {
            /**
             * Corner radius for the glass effect (0 for square corners)
             * @member
             * @type {number}
             */
            this["CornerRadius"] = 0;
        }
        if (!("TintColor" in $$source)) {
            /**
             * Tint color for the glass (optional, nil for no tint)
             * @member
             * @type {RGBA | null}
             */
            this["TintColor"] = null;
        }
        if (!("GroupID" in $$source)) {
            /**
             * Group identifier for merging multiple glass windows
             * @member
             * @type {string}
             */
            this["GroupID"] = "";
        }
        if (!("GroupSpacing" in $$source)) {
            /**
             * Spacing between grouped glass elements (in points)
             * @member
             * @type {number}
             */
            this["GroupSpacing"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacLiquidGlass instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MacLiquidGlass}
     */
    static createFrom($$source = {}) {
        const $$createField3_0 = $$createType27;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TintColor" in $$parsedSource) {
            $$parsedSource["TintColor"] = $$createField3_0($$parsedSource["TintColor"]);
        }
        return new MacLiquidGlass(/** @type {Partial<MacLiquidGlass>} */($$parsedSource));
    }
}

/**
 * MacLiquidGlassStyle defines the style of the Liquid Glass effect
 * @readonly
 * @enum {number}
 */
export const MacLiquidGlassStyle = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * LiquidGlassStyleAutomatic - System determines the best style
     */
    LiquidGlassStyleAutomatic: 0,

    /**
     * LiquidGlassStyleLight - Light glass appearance
     */
    LiquidGlassStyleLight: 1,

    /**
     * LiquidGlassStyleDark - Dark glass appearance
     */
    LiquidGlassStyleDark: 2,

    /**
     * LiquidGlassStyleVibrant - Vibrant glass with enhanced effects
     */
    LiquidGlassStyleVibrant: 3,
};

/**
 * MacTitleBar contains options for the Mac titlebar
 */
export class MacTitleBar {
    /**
     * Creates a new MacTitleBar instance.
     * @param {Partial<MacTitleBar>} [$$source = {}] - The source object to create the MacTitleBar.
     */
    constructor($$source = {}) {
        if (!("AppearsTransparent" in $$source)) {
            /**
             * AppearsTransparent will make the titlebar transparent
             * @member
             * @type {boolean}
             */
            this["AppearsTransparent"] = false;
        }
        if (!("Hide" in $$source)) {
            /**
             * Hide will hide the titlebar
             * @member
             * @type {boolean}
             */
            this["Hide"] = false;
        }
        if (!("HideTitle" in $$source)) {
            /**
             * HideTitle will hide the title
             * @member
             * @type {boolean}
             */
            this["HideTitle"] = false;
        }
        if (!("FullSizeContent" in $$source)) {
            /**
             * FullSizeContent will extend the window content to the full size of the window
             * @member
             * @type {boolean}
             */
            this["FullSizeContent"] = false;
        }
        if (!("UseToolbar" in $$source)) {
            /**
             * UseToolbar will use a toolbar instead of a titlebar
             * @member
             * @type {boolean}
             */
            this["UseToolbar"] = false;
        }
        if (!("HideToolbarSeparator" in $$source)) {
            /**
             * HideToolbarSeparator will hide the toolbar separator
             * @member
             * @type {boolean}
             */
            this["HideToolbarSeparator"] = false;
        }
        if (!("ShowToolbarWhenFullscreen" in $$source)) {
            /**
             * ShowToolbarWhenFullscreen will keep the toolbar visible when the window is in fullscreen mode
             * @member
             * @type {boolean}
             */
            this["ShowToolbarWhenFullscreen"] = false;
        }
        if (!("ToolbarStyle" in $$source)) {
            /**
             * ToolbarStyle is the style of toolbar to use
             * @member
             * @type {MacToolbarStyle}
             */
            this["ToolbarStyle"] = MacToolbarStyle.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacTitleBar instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MacTitleBar}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MacTitleBar(/** @type {Partial<MacTitleBar>} */($$parsedSource));
    }
}

/**
 * MacToolbarStyle is the style of toolbar for macOS
 * @readonly
 * @enum {number}
 */
export const MacToolbarStyle = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * MacToolbarStyleAutomatic - The default value. The style will be determined by the window's given configuration
     */
    MacToolbarStyleAutomatic: 0,

    /**
     * MacToolbarStyleExpanded - The toolbar will appear below the window title
     */
    MacToolbarStyleExpanded: 1,

    /**
     * MacToolbarStylePreference - The toolbar will appear below the window title and the items in the toolbar will attempt to have equal widths when possible
     */
    MacToolbarStylePreference: 2,

    /**
     * MacToolbarStyleUnified - The window title will appear inline with the toolbar when visible
     */
    MacToolbarStyleUnified: 3,

    /**
     * MacToolbarStyleUnifiedCompact - Same as MacToolbarStyleUnified, but with reduced margins in the toolbar allowing more focus to be on the contents of the window
     */
    MacToolbarStyleUnifiedCompact: 4,
};

/**
 * MacWebviewPreferences contains preferences for the Mac webview
 */
export class MacWebviewPreferences {
    /**
     * Creates a new MacWebviewPreferences instance.
     * @param {Partial<MacWebviewPreferences>} [$$source = {}] - The source object to create the MacWebviewPreferences.
     */
    constructor($$source = {}) {
        if (!("TabFocusesLinks" in $$source)) {
            /**
             * TabFocusesLinks will enable tabbing to links
             * @member
             * @type {u$0.Bool}
             */
            this["TabFocusesLinks"] = (new u$0.Bool());
        }
        if (!("TextInteractionEnabled" in $$source)) {
            /**
             * TextInteractionEnabled will enable text interaction
             * @member
             * @type {u$0.Bool}
             */
            this["TextInteractionEnabled"] = (new u$0.Bool());
        }
        if (!("FullscreenEnabled" in $$source)) {
            /**
             * FullscreenEnabled will enable fullscreen
             * @member
             * @type {u$0.Bool}
             */
            this["FullscreenEnabled"] = (new u$0.Bool());
        }
        if (!("AllowsBackForwardNavigationGestures" in $$source)) {
            /**
             * AllowsBackForwardNavigationGestures enables horizontal swipe gestures for back/forward navigation
             * @member
             * @type {u$0.Bool}
             */
            this["AllowsBackForwardNavigationGestures"] = (new u$0.Bool());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacWebviewPreferences instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MacWebviewPreferences}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType28;
        const $$createField1_0 = $$createType28;
        const $$createField2_0 = $$createType28;
        const $$createField3_0 = $$createType28;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TabFocusesLinks" in $$parsedSource) {
            $$parsedSource["TabFocusesLinks"] = $$createField0_0($$parsedSource["TabFocusesLinks"]);
        }
        if ("TextInteractionEnabled" in $$parsedSource) {
            $$parsedSource["TextInteractionEnabled"] = $$createField1_0($$parsedSource["TextInteractionEnabled"]);
        }
        if ("FullscreenEnabled" in $$parsedSource) {
            $$parsedSource["FullscreenEnabled"] = $$createField2_0($$parsedSource["FullscreenEnabled"]);
        }
        if ("AllowsBackForwardNavigationGestures" in $$parsedSource) {
            $$parsedSource["AllowsBackForwardNavigationGestures"] = $$createField3_0($$parsedSource["AllowsBackForwardNavigationGestures"]);
        }
        return new MacWebviewPreferences(/** @type {Partial<MacWebviewPreferences>} */($$parsedSource));
    }
}

/**
 * MacWindow contains macOS specific options for Webview Windows
 */
export class MacWindow {
    /**
     * Creates a new MacWindow instance.
     * @param {Partial<MacWindow>} [$$source = {}] - The source object to create the MacWindow.
     */
    constructor($$source = {}) {
        if (!("Backdrop" in $$source)) {
            /**
             * Backdrop is the backdrop type for the window
             * @member
             * @type {MacBackdrop}
             */
            this["Backdrop"] = MacBackdrop.$zero;
        }
        if (!("DisableShadow" in $$source)) {
            /**
             * DisableShadow will disable the window shadow
             * @member
             * @type {boolean}
             */
            this["DisableShadow"] = false;
        }
        if (!("TitleBar" in $$source)) {
            /**
             * TitleBar contains options for the Mac titlebar
             * @member
             * @type {MacTitleBar}
             */
            this["TitleBar"] = (new MacTitleBar());
        }
        if (!("Appearance" in $$source)) {
            /**
             * Appearance is the appearance type for the window
             * @member
             * @type {MacAppearanceType}
             */
            this["Appearance"] = MacAppearanceType.$zero;
        }
        if (!("InvisibleTitleBarHeight" in $$source)) {
            /**
             * InvisibleTitleBarHeight defines the height of an invisible titlebar which responds to dragging
             * @member
             * @type {number}
             */
            this["InvisibleTitleBarHeight"] = 0;
        }
        if (!("EventMapping" in $$source)) {
            /**
             * Maps events from platform specific to common event types
             * @member
             * @type {{ [_: `${number}`]: events$0.WindowEventType }}
             */
            this["EventMapping"] = {};
        }
        if (!("EnableFraudulentWebsiteWarnings" in $$source)) {
            /**
             * EnableFraudulentWebsiteWarnings will enable warnings for fraudulent websites.
             * Default: false
             * @member
             * @type {boolean}
             */
            this["EnableFraudulentWebsiteWarnings"] = false;
        }
        if (!("WebviewPreferences" in $$source)) {
            /**
             * WebviewPreferences contains preferences for the webview
             * @member
             * @type {MacWebviewPreferences}
             */
            this["WebviewPreferences"] = (new MacWebviewPreferences());
        }
        if (!("WindowLevel" in $$source)) {
            /**
             * WindowLevel sets the window level to control the order of windows in the screen
             * @member
             * @type {MacWindowLevel}
             */
            this["WindowLevel"] = MacWindowLevel.$zero;
        }
        if (!("LiquidGlass" in $$source)) {
            /**
             * LiquidGlass contains configuration for the Liquid Glass effect
             * @member
             * @type {MacLiquidGlass}
             */
            this["LiquidGlass"] = (new MacLiquidGlass());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacWindow instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MacWindow}
     */
    static createFrom($$source = {}) {
        const $$createField2_0 = $$createType29;
        const $$createField5_0 = $$createType30;
        const $$createField7_0 = $$createType31;
        const $$createField9_0 = $$createType32;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TitleBar" in $$parsedSource) {
            $$parsedSource["TitleBar"] = $$createField2_0($$parsedSource["TitleBar"]);
        }
        if ("EventMapping" in $$parsedSource) {
            $$parsedSource["EventMapping"] = $$createField5_0($$parsedSource["EventMapping"]);
        }
        if ("WebviewPreferences" in $$parsedSource) {
            $$parsedSource["WebviewPreferences"] = $$createField7_0($$parsedSource["WebviewPreferences"]);
        }
        if ("LiquidGlass" in $$parsedSource) {
            $$parsedSource["LiquidGlass"] = $$createField9_0($$parsedSource["LiquidGlass"]);
        }
        return new MacWindow(/** @type {Partial<MacWindow>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {string}
 */
export const MacWindowLevel = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: "",

    MacWindowLevelNormal: "normal",
    MacWindowLevelFloating: "floating",
    MacWindowLevelTornOffMenu: "tornOffMenu",
    MacWindowLevelModalPanel: "modalPanel",
    MacWindowLevelMainMenu: "mainMenu",
    MacWindowLevelStatus: "status",
    MacWindowLevelPopUpMenu: "popUpMenu",
    MacWindowLevelScreenSaver: "screenSaver",
};

export class Menu {
    /**
     * Creates a new Menu instance.
     * @param {Partial<Menu>} [$$source = {}] - The source object to create the Menu.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Menu instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {Menu}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Menu(/** @type {Partial<Menu>} */($$parsedSource));
    }
}

export class MenuBarTheme {
    /**
     * Creates a new MenuBarTheme instance.
     * @param {Partial<MenuBarTheme>} [$$source = {}] - The source object to create the MenuBarTheme.
     */
    constructor($$source = {}) {
        if (!("Default" in $$source)) {
            /**
             * Default is the default theme
             * @member
             * @type {TextTheme | null}
             */
            this["Default"] = null;
        }
        if (!("Hover" in $$source)) {
            /**
             * Hover defines the theme to use when the menu item is hovered
             * @member
             * @type {TextTheme | null}
             */
            this["Hover"] = null;
        }
        if (!("Selected" in $$source)) {
            /**
             * Selected defines the theme to use when the menu item is selected
             * @member
             * @type {TextTheme | null}
             */
            this["Selected"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MenuBarTheme instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MenuBarTheme}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType34;
        const $$createField1_0 = $$createType34;
        const $$createField2_0 = $$createType34;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Default" in $$parsedSource) {
            $$parsedSource["Default"] = $$createField0_0($$parsedSource["Default"]);
        }
        if ("Hover" in $$parsedSource) {
            $$parsedSource["Hover"] = $$createField1_0($$parsedSource["Hover"]);
        }
        if ("Selected" in $$parsedSource) {
            $$parsedSource["Selected"] = $$createField2_0($$parsedSource["Selected"]);
        }
        return new MenuBarTheme(/** @type {Partial<MenuBarTheme>} */($$parsedSource));
    }
}

/**
 * MenuManager manages menu-related operations
 */
export class MenuManager {
    /**
     * Creates a new MenuManager instance.
     * @param {Partial<MenuManager>} [$$source = {}] - The source object to create the MenuManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MenuManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MenuManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MenuManager(/** @type {Partial<MenuManager>} */($$parsedSource));
    }
}

/**
 * NSVisualEffectMaterial represents the NSVisualEffectMaterial enum for macOS
 * @readonly
 * @enum {number}
 */
export const NSVisualEffectMaterial = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * NSVisualEffectMaterial values from macOS SDK
     */
    NSVisualEffectMaterialAppearanceBased: 0,
    NSVisualEffectMaterialLight: 1,
    NSVisualEffectMaterialDark: 2,
    NSVisualEffectMaterialTitlebar: 3,
    NSVisualEffectMaterialSelection: 4,
    NSVisualEffectMaterialMenu: 5,
    NSVisualEffectMaterialPopover: 6,
    NSVisualEffectMaterialSidebar: 7,
    NSVisualEffectMaterialHeaderView: 10,
    NSVisualEffectMaterialSheet: 11,
    NSVisualEffectMaterialWindowBackground: 12,
    NSVisualEffectMaterialHUDWindow: 13,
    NSVisualEffectMaterialFullScreenUI: 15,
    NSVisualEffectMaterialToolTip: 17,
    NSVisualEffectMaterialContentBackground: 18,
    NSVisualEffectMaterialUnderWindowBackground: 21,
    NSVisualEffectMaterialUnderPageBackground: 22,

    /**
     * Use auto-selection based on Style
     */
    NSVisualEffectMaterialAuto: -1,
};

export class RGBA {
    /**
     * Creates a new RGBA instance.
     * @param {Partial<RGBA>} [$$source = {}] - The source object to create the RGBA.
     */
    constructor($$source = {}) {
        if (!("Red" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["Red"] = 0;
        }
        if (!("Green" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["Green"] = 0;
        }
        if (!("Blue" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["Blue"] = 0;
        }
        if (!("Alpha" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["Alpha"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RGBA instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {RGBA}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new RGBA(/** @type {Partial<RGBA>} */($$parsedSource));
    }
}

export class ScreenManager {
    /**
     * Creates a new ScreenManager instance.
     * @param {Partial<ScreenManager>} [$$source = {}] - The source object to create the ScreenManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ScreenManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ScreenManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ScreenManager(/** @type {Partial<ScreenManager>} */($$parsedSource));
    }
}

/**
 * SystemTrayManager manages system tray-related operations
 */
export class SystemTrayManager {
    /**
     * Creates a new SystemTrayManager instance.
     * @param {Partial<SystemTrayManager>} [$$source = {}] - The source object to create the SystemTrayManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new SystemTrayManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {SystemTrayManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new SystemTrayManager(/** @type {Partial<SystemTrayManager>} */($$parsedSource));
    }
}

export class TextTheme {
    /**
     * Creates a new TextTheme instance.
     * @param {Partial<TextTheme>} [$$source = {}] - The source object to create the TextTheme.
     */
    constructor($$source = {}) {
        if (!("Text" in $$source)) {
            /**
             * Text is the colour of the text
             * @member
             * @type {number | null}
             */
            this["Text"] = null;
        }
        if (!("Background" in $$source)) {
            /**
             * Background is the background colour of the text
             * @member
             * @type {number | null}
             */
            this["Background"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TextTheme instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {TextTheme}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TextTheme(/** @type {Partial<TextTheme>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {number}
 */
export const Theme = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * SystemDefault will use whatever the system theme is. The application will follow system theme changes.
     */
    SystemDefault: 0,

    /**
     * Dark Mode
     */
    Dark: 1,

    /**
     * Light Mode
     */
    Light: 2,
};

/**
 * ThemeSettings defines custom colours to use in dark or light mode.
 * They may be set using the hex values: 0x00BBGGRR
 */
export class ThemeSettings {
    /**
     * Creates a new ThemeSettings instance.
     * @param {Partial<ThemeSettings>} [$$source = {}] - The source object to create the ThemeSettings.
     */
    constructor($$source = {}) {
        if (!("DarkModeActive" in $$source)) {
            /**
             * Dark mode active window
             * @member
             * @type {WindowTheme | null}
             */
            this["DarkModeActive"] = null;
        }
        if (!("DarkModeInactive" in $$source)) {
            /**
             * Dark mode inactive window
             * @member
             * @type {WindowTheme | null}
             */
            this["DarkModeInactive"] = null;
        }
        if (!("LightModeActive" in $$source)) {
            /**
             * Light mode active window
             * @member
             * @type {WindowTheme | null}
             */
            this["LightModeActive"] = null;
        }
        if (!("LightModeInactive" in $$source)) {
            /**
             * Light mode inactive window
             * @member
             * @type {WindowTheme | null}
             */
            this["LightModeInactive"] = null;
        }
        if (!("DarkModeMenuBar" in $$source)) {
            /**
             * Dark mode MenuBar
             * @member
             * @type {MenuBarTheme | null}
             */
            this["DarkModeMenuBar"] = null;
        }
        if (!("LightModeMenuBar" in $$source)) {
            /**
             * Light mode MenuBar
             * @member
             * @type {MenuBarTheme | null}
             */
            this["LightModeMenuBar"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ThemeSettings instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ThemeSettings}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType36;
        const $$createField1_0 = $$createType36;
        const $$createField2_0 = $$createType36;
        const $$createField3_0 = $$createType36;
        const $$createField4_0 = $$createType38;
        const $$createField5_0 = $$createType38;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("DarkModeActive" in $$parsedSource) {
            $$parsedSource["DarkModeActive"] = $$createField0_0($$parsedSource["DarkModeActive"]);
        }
        if ("DarkModeInactive" in $$parsedSource) {
            $$parsedSource["DarkModeInactive"] = $$createField1_0($$parsedSource["DarkModeInactive"]);
        }
        if ("LightModeActive" in $$parsedSource) {
            $$parsedSource["LightModeActive"] = $$createField2_0($$parsedSource["LightModeActive"]);
        }
        if ("LightModeInactive" in $$parsedSource) {
            $$parsedSource["LightModeInactive"] = $$createField3_0($$parsedSource["LightModeInactive"]);
        }
        if ("DarkModeMenuBar" in $$parsedSource) {
            $$parsedSource["DarkModeMenuBar"] = $$createField4_0($$parsedSource["DarkModeMenuBar"]);
        }
        if ("LightModeMenuBar" in $$parsedSource) {
            $$parsedSource["LightModeMenuBar"] = $$createField5_0($$parsedSource["LightModeMenuBar"]);
        }
        return new ThemeSettings(/** @type {Partial<ThemeSettings>} */($$parsedSource));
    }
}

/**
 * WebviewGpuPolicy values used for determining the webview's hardware acceleration policy.
 * @readonly
 * @enum {number}
 */
export const WebviewGpuPolicy = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    /**
     * WebviewGpuPolicyAlways Hardware acceleration is always enabled.
     */
    WebviewGpuPolicyAlways: 0,

    /**
     * WebviewGpuPolicyOnDemand Hardware acceleration is enabled/disabled as request by web contents.
     */
    WebviewGpuPolicyOnDemand: 1,

    /**
     * WebviewGpuPolicyNever Hardware acceleration is always disabled.
     */
    WebviewGpuPolicyNever: 2,
};

export class WebviewWindowOptions {
    /**
     * Creates a new WebviewWindowOptions instance.
     * @param {Partial<WebviewWindowOptions>} [$$source = {}] - The source object to create the WebviewWindowOptions.
     */
    constructor($$source = {}) {
        if (!("Name" in $$source)) {
            /**
             * Name is a unique identifier that can be given to a window.
             * @member
             * @type {string}
             */
            this["Name"] = "";
        }
        if (!("Title" in $$source)) {
            /**
             * Title is the title of the window.
             * @member
             * @type {string}
             */
            this["Title"] = "";
        }
        if (!("Width" in $$source)) {
            /**
             * Width is the starting width of the window.
             * @member
             * @type {number}
             */
            this["Width"] = 0;
        }
        if (!("Height" in $$source)) {
            /**
             * Height is the starting height of the window.
             * @member
             * @type {number}
             */
            this["Height"] = 0;
        }
        if (!("AlwaysOnTop" in $$source)) {
            /**
             * AlwaysOnTop will make the window float above other windows.
             * @member
             * @type {boolean}
             */
            this["AlwaysOnTop"] = false;
        }
        if (!("URL" in $$source)) {
            /**
             * URL is the URL to load in the window.
             * @member
             * @type {string}
             */
            this["URL"] = "";
        }
        if (!("DisableResize" in $$source)) {
            /**
             * DisableResize will disable the ability to resize the window.
             * @member
             * @type {boolean}
             */
            this["DisableResize"] = false;
        }
        if (!("Frameless" in $$source)) {
            /**
             * Frameless will remove the window frame.
             * @member
             * @type {boolean}
             */
            this["Frameless"] = false;
        }
        if (!("MinWidth" in $$source)) {
            /**
             * MinWidth is the minimum width of the window.
             * @member
             * @type {number}
             */
            this["MinWidth"] = 0;
        }
        if (!("MinHeight" in $$source)) {
            /**
             * MinHeight is the minimum height of the window.
             * @member
             * @type {number}
             */
            this["MinHeight"] = 0;
        }
        if (!("MaxWidth" in $$source)) {
            /**
             * MaxWidth is the maximum width of the window.
             * @member
             * @type {number}
             */
            this["MaxWidth"] = 0;
        }
        if (!("MaxHeight" in $$source)) {
            /**
             * MaxHeight is the maximum height of the window.
             * @member
             * @type {number}
             */
            this["MaxHeight"] = 0;
        }
        if (!("StartState" in $$source)) {
            /**
             * StartState indicates the state of the window when it is first shown.
             * Default: WindowStateNormal
             * @member
             * @type {WindowState}
             */
            this["StartState"] = WindowState.$zero;
        }
        if (!("BackgroundType" in $$source)) {
            /**
             * BackgroundType is the type of background to use for the window.
             * Default: BackgroundTypeSolid
             * @member
             * @type {BackgroundType}
             */
            this["BackgroundType"] = BackgroundType.$zero;
        }
        if (!("BackgroundColour" in $$source)) {
            /**
             * BackgroundColour is the colour to use for the window background.
             * @member
             * @type {RGBA}
             */
            this["BackgroundColour"] = (new RGBA());
        }
        if (!("HTML" in $$source)) {
            /**
             * HTML is the HTML to load in the window.
             * @member
             * @type {string}
             */
            this["HTML"] = "";
        }
        if (!("JS" in $$source)) {
            /**
             * JS is the JavaScript to load in the window.
             * @member
             * @type {string}
             */
            this["JS"] = "";
        }
        if (!("CSS" in $$source)) {
            /**
             * CSS is the CSS to load in the window.
             * @member
             * @type {string}
             */
            this["CSS"] = "";
        }
        if (!("InitialPosition" in $$source)) {
            /**
             * Initial Position
             * @member
             * @type {WindowStartPosition}
             */
            this["InitialPosition"] = WindowStartPosition.$zero;
        }
        if (!("X" in $$source)) {
            /**
             * X is the starting X position of the window.
             * @member
             * @type {number}
             */
            this["X"] = 0;
        }
        if (!("Y" in $$source)) {
            /**
             * Y is the starting Y position of the window.
             * @member
             * @type {number}
             */
            this["Y"] = 0;
        }
        if (!("Hidden" in $$source)) {
            /**
             * Hidden will hide the window when it is first created.
             * @member
             * @type {boolean}
             */
            this["Hidden"] = false;
        }
        if (!("Zoom" in $$source)) {
            /**
             * Zoom is the zoom level of the window.
             * @member
             * @type {number}
             */
            this["Zoom"] = 0;
        }
        if (!("ZoomControlEnabled" in $$source)) {
            /**
             * ZoomControlEnabled will enable the zoom control.
             * @member
             * @type {boolean}
             */
            this["ZoomControlEnabled"] = false;
        }
        if (!("EnableDragAndDrop" in $$source)) {
            /**
             * EnableDragAndDrop will enable drag and drop.
             * @member
             * @type {boolean}
             */
            this["EnableDragAndDrop"] = false;
        }
        if (!("OpenInspectorOnStartup" in $$source)) {
            /**
             * OpenInspectorOnStartup will open the inspector when the window is first shown.
             * @member
             * @type {boolean}
             */
            this["OpenInspectorOnStartup"] = false;
        }
        if (!("Mac" in $$source)) {
            /**
             * Mac options
             * @member
             * @type {MacWindow}
             */
            this["Mac"] = (new MacWindow());
        }
        if (!("Windows" in $$source)) {
            /**
             * Windows options
             * @member
             * @type {WindowsWindow}
             */
            this["Windows"] = (new WindowsWindow());
        }
        if (!("Linux" in $$source)) {
            /**
             * Linux options
             * @member
             * @type {LinuxWindow}
             */
            this["Linux"] = (new LinuxWindow());
        }
        if (!("MinimiseButtonState" in $$source)) {
            /**
             * Toolbar button states
             * @member
             * @type {ButtonState}
             */
            this["MinimiseButtonState"] = ButtonState.$zero;
        }
        if (!("MaximiseButtonState" in $$source)) {
            /**
             * @member
             * @type {ButtonState}
             */
            this["MaximiseButtonState"] = ButtonState.$zero;
        }
        if (!("CloseButtonState" in $$source)) {
            /**
             * @member
             * @type {ButtonState}
             */
            this["CloseButtonState"] = ButtonState.$zero;
        }
        if (!("DevToolsEnabled" in $$source)) {
            /**
             * If true, the window's devtools will be available (default true in builds without the `production` build tag)
             * @member
             * @type {boolean}
             */
            this["DevToolsEnabled"] = false;
        }
        if (!("DefaultContextMenuDisabled" in $$source)) {
            /**
             * If true, the window's default context menu will be disabled (default false)
             * @member
             * @type {boolean}
             */
            this["DefaultContextMenuDisabled"] = false;
        }
        if (!("KeyBindings" in $$source)) {
            /**
             * KeyBindings is a map of key bindings to functions
             * @member
             * @type {{ [_: string]: any }}
             */
            this["KeyBindings"] = {};
        }
        if (!("IgnoreMouseEvents" in $$source)) {
            /**
             * IgnoreMouseEvents will ignore mouse events in the window (Windows + Mac only)
             * @member
             * @type {boolean}
             */
            this["IgnoreMouseEvents"] = false;
        }
        if (!("ContentProtectionEnabled" in $$source)) {
            /**
             * ContentProtectionEnabled specifies whether content protection is enabled, preventing screen capture and recording.
             * Effective on Windows and macOS only; no-op on Linux.
             * Best-effort protection with platform-specific caveats (see docs).
             * @member
             * @type {boolean}
             */
            this["ContentProtectionEnabled"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WebviewWindowOptions instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {WebviewWindowOptions}
     */
    static createFrom($$source = {}) {
        const $$createField14_0 = $$createType26;
        const $$createField26_0 = $$createType39;
        const $$createField27_0 = $$createType40;
        const $$createField28_0 = $$createType41;
        const $$createField34_0 = $$createType42;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("BackgroundColour" in $$parsedSource) {
            $$parsedSource["BackgroundColour"] = $$createField14_0($$parsedSource["BackgroundColour"]);
        }
        if ("Mac" in $$parsedSource) {
            $$parsedSource["Mac"] = $$createField26_0($$parsedSource["Mac"]);
        }
        if ("Windows" in $$parsedSource) {
            $$parsedSource["Windows"] = $$createField27_0($$parsedSource["Windows"]);
        }
        if ("Linux" in $$parsedSource) {
            $$parsedSource["Linux"] = $$createField28_0($$parsedSource["Linux"]);
        }
        if ("KeyBindings" in $$parsedSource) {
            $$parsedSource["KeyBindings"] = $$createField34_0($$parsedSource["KeyBindings"]);
        }
        return new WebviewWindowOptions(/** @type {Partial<WebviewWindowOptions>} */($$parsedSource));
    }
}

/**
 * WindowManager manages all window-related operations
 */
export class WindowManager {
    /**
     * Creates a new WindowManager instance.
     * @param {Partial<WindowManager>} [$$source = {}] - The source object to create the WindowManager.
     */
    constructor($$source = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowManager instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {WindowManager}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WindowManager(/** @type {Partial<WindowManager>} */($$parsedSource));
    }
}

/**
 * @readonly
 * @enum {number}
 */
export const WindowStartPosition = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    WindowCentered: 0,
    WindowXY: 1,
};

/**
 * @readonly
 * @enum {number}
 */
export const WindowState = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: 0,

    WindowStateNormal: 0,
    WindowStateMinimised: 1,
    WindowStateMaximised: 2,
    WindowStateFullscreen: 3,
};

export class WindowTheme {
    /**
     * Creates a new WindowTheme instance.
     * @param {Partial<WindowTheme>} [$$source = {}] - The source object to create the WindowTheme.
     */
    constructor($$source = {}) {
        if (!("BorderColour" in $$source)) {
            /**
             * BorderColour is the colour of the window border
             * @member
             * @type {number | null}
             */
            this["BorderColour"] = null;
        }
        if (!("TitleBarColour" in $$source)) {
            /**
             * TitleBarColour is the colour of the window title bar
             * @member
             * @type {number | null}
             */
            this["TitleBarColour"] = null;
        }
        if (!("TitleTextColour" in $$source)) {
            /**
             * TitleTextColour is the colour of the window title text
             * @member
             * @type {number | null}
             */
            this["TitleTextColour"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowTheme instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {WindowTheme}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WindowTheme(/** @type {Partial<WindowTheme>} */($$parsedSource));
    }
}

export class WindowsWindow {
    /**
     * Creates a new WindowsWindow instance.
     * @param {Partial<WindowsWindow>} [$$source = {}] - The source object to create the WindowsWindow.
     */
    constructor($$source = {}) {
        if (!("BackdropType" in $$source)) {
            /**
             * Select the type of translucent backdrop. Requires Windows 11 22621 or later.
             * Only used when window's `BackgroundType` is set to `BackgroundTypeTranslucent`.
             * Default: Auto
             * @member
             * @type {BackdropType}
             */
            this["BackdropType"] = BackdropType.$zero;
        }
        if (!("DisableIcon" in $$source)) {
            /**
             * Disable the icon in the titlebar
             * Default: false
             * @member
             * @type {boolean}
             */
            this["DisableIcon"] = false;
        }
        if (!("Theme" in $$source)) {
            /**
             * Theme (Dark / Light / SystemDefault)
             * Default: SystemDefault - The application will follow system theme changes.
             * @member
             * @type {Theme}
             */
            this["Theme"] = Theme.$zero;
        }
        if (!("CustomTheme" in $$source)) {
            /**
             * Specify custom colours to use for dark/light mode
             * Default: nil
             * @member
             * @type {ThemeSettings}
             */
            this["CustomTheme"] = (new ThemeSettings());
        }
        if (!("DisableFramelessWindowDecorations" in $$source)) {
            /**
             * Disable all window decorations in Frameless mode, which means no "Aero Shadow" and no "Rounded Corner" will be shown.
             * "Rounded Corners" are only available on Windows 11.
             * Default: false
             * @member
             * @type {boolean}
             */
            this["DisableFramelessWindowDecorations"] = false;
        }
        if (!("WindowMask" in $$source)) {
            /**
             * WindowMask is used to set the window shape. Use a PNG with an alpha channel to create a custom shape.
             * Default: nil
             * @member
             * @type {string}
             */
            this["WindowMask"] = "";
        }
        if (!("WindowMaskDraggable" in $$source)) {
            /**
             * WindowMaskDraggable is used to make the window draggable by clicking on the window mask.
             * Default: false
             * @member
             * @type {boolean}
             */
            this["WindowMaskDraggable"] = false;
        }
        if (!("ResizeDebounceMS" in $$source)) {
            /**
             * ResizeDebounceMS is the amount of time to debounce redraws of webview2
             * when resizing the window
             * Default: 0
             * @member
             * @type {number}
             */
            this["ResizeDebounceMS"] = 0;
        }
        if (!("WindowDidMoveDebounceMS" in $$source)) {
            /**
             * WindowDidMoveDebounceMS is the amount of time to debounce the WindowDidMove event
             * when moving the window
             * Default: 0
             * @member
             * @type {number}
             */
            this["WindowDidMoveDebounceMS"] = 0;
        }
        if (!("EventMapping" in $$source)) {
            /**
             * Event mapping for the window. This allows you to define a translation from one event to another.
             * Default: nil
             * @member
             * @type {{ [_: `${number}`]: events$0.WindowEventType }}
             */
            this["EventMapping"] = {};
        }
        if (!("HiddenOnTaskbar" in $$source)) {
            /**
             * HiddenOnTaskbar hides the window from the taskbar
             * Default: false
             * @member
             * @type {boolean}
             */
            this["HiddenOnTaskbar"] = false;
        }
        if (!("EnableSwipeGestures" in $$source)) {
            /**
             * EnableSwipeGestures enables swipe gestures for the window
             * Default: false
             * @member
             * @type {boolean}
             */
            this["EnableSwipeGestures"] = false;
        }
        if (!("Menu" in $$source)) {
            /**
             * Menu is the menu to use for the window.
             * @member
             * @type {Menu | null}
             */
            this["Menu"] = null;
        }
        if (!("OnEnterEffect" in $$source)) {
            /**
             * Drag Cursor Effects
             * @member
             * @type {DragEffect}
             */
            this["OnEnterEffect"] = DragEffect.$zero;
        }
        if (!("OnOverEffect" in $$source)) {
            /**
             * @member
             * @type {DragEffect}
             */
            this["OnOverEffect"] = DragEffect.$zero;
        }
        if (!("Permissions" in $$source)) {
            /**
             * Permissions map for WebView2. If empty, default permissions will be granted.
             * @member
             * @type {{ [_: `${number}`]: CoreWebView2PermissionState }}
             */
            this["Permissions"] = {};
        }
        if (!("ExStyle" in $$source)) {
            /**
             * ExStyle is the extended window style
             * @member
             * @type {number}
             */
            this["ExStyle"] = 0;
        }
        if (!("GeneralAutofillEnabled" in $$source)) {
            /**
             * GeneralAutofillEnabled enables general autofill
             * @member
             * @type {boolean}
             */
            this["GeneralAutofillEnabled"] = false;
        }
        if (!("PasswordAutosaveEnabled" in $$source)) {
            /**
             * PasswordAutosaveEnabled enables autosaving passwords
             * @member
             * @type {boolean}
             */
            this["PasswordAutosaveEnabled"] = false;
        }
        if (!("EnabledFeatures" in $$source)) {
            /**
             * EnabledFeatures, DisabledFeatures and AdditionalLaunchArgs are used to enable or disable specific features in the WebView2 browser.
             * Available flags: https://learn.microsoft.com/en-us/microsoft-edge/webview2/concepts/webview-features-flags?tabs=dotnetcsharp#available-webview2-browser-flags
             * WARNING: Apps in production shouldn't use WebView2 browser flags,
             * because these flags might be removed or altered at any time,
             * and aren't necessarily supported long-term.
             * AdditionalLaunchArgs should always be preceded by "--"
             * @member
             * @type {string[]}
             */
            this["EnabledFeatures"] = [];
        }
        if (!("DisabledFeatures" in $$source)) {
            /**
             * @member
             * @type {string[]}
             */
            this["DisabledFeatures"] = [];
        }
        if (!("AdditionalLaunchArgs" in $$source)) {
            /**
             * @member
             * @type {string[]}
             */
            this["AdditionalLaunchArgs"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowsWindow instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {WindowsWindow}
     */
    static createFrom($$source = {}) {
        const $$createField3_0 = $$createType43;
        const $$createField5_0 = $Create.ByteSlice;
        const $$createField9_0 = $$createType30;
        const $$createField12_0 = $$createType25;
        const $$createField15_0 = $$createType44;
        const $$createField19_0 = $$createType45;
        const $$createField20_0 = $$createType45;
        const $$createField21_0 = $$createType45;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("CustomTheme" in $$parsedSource) {
            $$parsedSource["CustomTheme"] = $$createField3_0($$parsedSource["CustomTheme"]);
        }
        if ("WindowMask" in $$parsedSource) {
            $$parsedSource["WindowMask"] = $$createField5_0($$parsedSource["WindowMask"]);
        }
        if ("EventMapping" in $$parsedSource) {
            $$parsedSource["EventMapping"] = $$createField9_0($$parsedSource["EventMapping"]);
        }
        if ("Menu" in $$parsedSource) {
            $$parsedSource["Menu"] = $$createField12_0($$parsedSource["Menu"]);
        }
        if ("Permissions" in $$parsedSource) {
            $$parsedSource["Permissions"] = $$createField15_0($$parsedSource["Permissions"]);
        }
        if ("EnabledFeatures" in $$parsedSource) {
            $$parsedSource["EnabledFeatures"] = $$createField19_0($$parsedSource["EnabledFeatures"]);
        }
        if ("DisabledFeatures" in $$parsedSource) {
            $$parsedSource["DisabledFeatures"] = $$createField20_0($$parsedSource["DisabledFeatures"]);
        }
        if ("AdditionalLaunchArgs" in $$parsedSource) {
            $$parsedSource["AdditionalLaunchArgs"] = $$createField21_0($$parsedSource["AdditionalLaunchArgs"]);
        }
        return new WindowsWindow(/** @type {Partial<WindowsWindow>} */($$parsedSource));
    }
}

// Private type creation functions
const $$createType0 = WindowManager.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
const $$createType2 = ContextMenuManager.createFrom;
const $$createType3 = $Create.Nullable($$createType2);
const $$createType4 = KeyBindingManager.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
const $$createType6 = BrowserManager.createFrom;
const $$createType7 = $Create.Nullable($$createType6);
const $$createType8 = EnvironmentManager.createFrom;
const $$createType9 = $Create.Nullable($$createType8);
const $$createType10 = DialogManager.createFrom;
const $$createType11 = $Create.Nullable($$createType10);
const $$createType12 = EventManager.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
const $$createType14 = MenuManager.createFrom;
const $$createType15 = $Create.Nullable($$createType14);
const $$createType16 = ScreenManager.createFrom;
const $$createType17 = $Create.Nullable($$createType16);
const $$createType18 = ClipboardManager.createFrom;
const $$createType19 = $Create.Nullable($$createType18);
const $$createType20 = SystemTrayManager.createFrom;
const $$createType21 = $Create.Nullable($$createType20);
const $$createType22 = slog$0.Logger.createFrom;
const $$createType23 = $Create.Nullable($$createType22);
const $$createType24 = Menu.createFrom;
const $$createType25 = $Create.Nullable($$createType24);
const $$createType26 = RGBA.createFrom;
const $$createType27 = $Create.Nullable($$createType26);
const $$createType28 = u$0.Var.createFrom($Create.Any);
const $$createType29 = MacTitleBar.createFrom;
const $$createType30 = $Create.Map($Create.Any, $Create.Any);
const $$createType31 = MacWebviewPreferences.createFrom;
const $$createType32 = MacLiquidGlass.createFrom;
const $$createType33 = TextTheme.createFrom;
const $$createType34 = $Create.Nullable($$createType33);
const $$createType35 = WindowTheme.createFrom;
const $$createType36 = $Create.Nullable($$createType35);
const $$createType37 = MenuBarTheme.createFrom;
const $$createType38 = $Create.Nullable($$createType37);
const $$createType39 = MacWindow.createFrom;
const $$createType40 = WindowsWindow.createFrom;
const $$createType41 = LinuxWindow.createFrom;
const $$createType42 = $Create.Map($Create.Any, $Create.Any);
const $$createType43 = ThemeSettings.createFrom;
const $$createType44 = $Create.Map($Create.Any, $Create.Any);
const $$createType45 = $Create.Array($Create.Any);
