// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as u$0 from "../../../../../leaanthony/u/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as events$0 from "../events/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as slog$0 from "../../../../../../log/slog/models.js";

export class App {
    /**
     * Manager pattern for organized API
     */
    "Window": WindowManager | null;
    "ContextMenu": ContextMenuManager | null;
    "KeyBinding": KeyBindingManager | null;
    "Browser": BrowserManager | null;
    "Env": EnvironmentManager | null;
    "Dialog": DialogManager | null;
    "Event": EventManager | null;
    "Menu": MenuManager | null;
    "Screen": ScreenManager | null;
    "Clipboard": ClipboardManager | null;
    "SystemTray": SystemTrayManager | null;
    "Logger": slog$0.Logger | null;

    /** Creates a new App instance. */
    constructor($$source: Partial<App> = {}) {
        if (!("Window" in $$source)) {
            this["Window"] = null;
        }
        if (!("ContextMenu" in $$source)) {
            this["ContextMenu"] = null;
        }
        if (!("KeyBinding" in $$source)) {
            this["KeyBinding"] = null;
        }
        if (!("Browser" in $$source)) {
            this["Browser"] = null;
        }
        if (!("Env" in $$source)) {
            this["Env"] = null;
        }
        if (!("Dialog" in $$source)) {
            this["Dialog"] = null;
        }
        if (!("Event" in $$source)) {
            this["Event"] = null;
        }
        if (!("Menu" in $$source)) {
            this["Menu"] = null;
        }
        if (!("Screen" in $$source)) {
            this["Screen"] = null;
        }
        if (!("Clipboard" in $$source)) {
            this["Clipboard"] = null;
        }
        if (!("SystemTray" in $$source)) {
            this["SystemTray"] = null;
        }
        if (!("Logger" in $$source)) {
            this["Logger"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new App instance from a string or object.
     */
    static createFrom($$source: any = {}): App {
        const $$createField0_0 = $$createType1;
        const $$createField1_0 = $$createType3;
        const $$createField2_0 = $$createType5;
        const $$createField3_0 = $$createType7;
        const $$createField4_0 = $$createType9;
        const $$createField5_0 = $$createType11;
        const $$createField6_0 = $$createType13;
        const $$createField7_0 = $$createType15;
        const $$createField8_0 = $$createType17;
        const $$createField9_0 = $$createType19;
        const $$createField10_0 = $$createType21;
        const $$createField11_0 = $$createType23;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Window" in $$parsedSource) {
            $$parsedSource["Window"] = $$createField0_0($$parsedSource["Window"]);
        }
        if ("ContextMenu" in $$parsedSource) {
            $$parsedSource["ContextMenu"] = $$createField1_0($$parsedSource["ContextMenu"]);
        }
        if ("KeyBinding" in $$parsedSource) {
            $$parsedSource["KeyBinding"] = $$createField2_0($$parsedSource["KeyBinding"]);
        }
        if ("Browser" in $$parsedSource) {
            $$parsedSource["Browser"] = $$createField3_0($$parsedSource["Browser"]);
        }
        if ("Env" in $$parsedSource) {
            $$parsedSource["Env"] = $$createField4_0($$parsedSource["Env"]);
        }
        if ("Dialog" in $$parsedSource) {
            $$parsedSource["Dialog"] = $$createField5_0($$parsedSource["Dialog"]);
        }
        if ("Event" in $$parsedSource) {
            $$parsedSource["Event"] = $$createField6_0($$parsedSource["Event"]);
        }
        if ("Menu" in $$parsedSource) {
            $$parsedSource["Menu"] = $$createField7_0($$parsedSource["Menu"]);
        }
        if ("Screen" in $$parsedSource) {
            $$parsedSource["Screen"] = $$createField8_0($$parsedSource["Screen"]);
        }
        if ("Clipboard" in $$parsedSource) {
            $$parsedSource["Clipboard"] = $$createField9_0($$parsedSource["Clipboard"]);
        }
        if ("SystemTray" in $$parsedSource) {
            $$parsedSource["SystemTray"] = $$createField10_0($$parsedSource["SystemTray"]);
        }
        if ("Logger" in $$parsedSource) {
            $$parsedSource["Logger"] = $$createField11_0($$parsedSource["Logger"]);
        }
        return new App($$parsedSource as Partial<App>);
    }
}

export enum BackdropType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    Auto = 0,
    None = 1,
    Mica = 2,
    Acrylic = 3,
    Tabbed = 4,
};

export enum BackgroundType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    BackgroundTypeSolid = 0,
    BackgroundTypeTransparent = 1,
    BackgroundTypeTranslucent = 2,
};

/**
 * BrowserManager manages browser-related operations
 */
export class BrowserManager {

    /** Creates a new BrowserManager instance. */
    constructor($$source: Partial<BrowserManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new BrowserManager instance from a string or object.
     */
    static createFrom($$source: any = {}): BrowserManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new BrowserManager($$parsedSource as Partial<BrowserManager>);
    }
}

export enum ButtonState {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    ButtonEnabled = 0,
    ButtonDisabled = 1,
    ButtonHidden = 2,
};

/**
 * ClipboardManager manages clipboard operations
 */
export class ClipboardManager {

    /** Creates a new ClipboardManager instance. */
    constructor($$source: Partial<ClipboardManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClipboardManager instance from a string or object.
     */
    static createFrom($$source: any = {}): ClipboardManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ClipboardManager($$parsedSource as Partial<ClipboardManager>);
    }
}

/**
 * ContextMenuManager manages all context menu operations
 */
export class ContextMenuManager {

    /** Creates a new ContextMenuManager instance. */
    constructor($$source: Partial<ContextMenuManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ContextMenuManager instance from a string or object.
     */
    static createFrom($$source: any = {}): ContextMenuManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ContextMenuManager($$parsedSource as Partial<ContextMenuManager>);
    }
}

export enum CoreWebView2PermissionState {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    CoreWebView2PermissionStateDefault = 0,
    CoreWebView2PermissionStateAllow = 1,
    CoreWebView2PermissionStateDeny = 2,
};

/**
 * DialogManager manages dialog-related operations
 */
export class DialogManager {

    /** Creates a new DialogManager instance. */
    constructor($$source: Partial<DialogManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new DialogManager instance from a string or object.
     */
    static createFrom($$source: any = {}): DialogManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new DialogManager($$parsedSource as Partial<DialogManager>);
    }
}

export enum DragEffect {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * DragEffectNone is used to indicate that the drop target cannot accept the data.
     */
    DragEffectNone = 1,

    /**
     * DragEffectCopy is used to indicate that the data is copied to the drop target.
     */
    DragEffectCopy = 2,

    /**
     * DragEffectMove is used to indicate that the data is removed from the drag source.
     */
    DragEffectMove = 3,

    /**
     * DragEffectLink is used to indicate that a link to the original data is established.
     */
    DragEffectLink = 4,
};

/**
 * EnvironmentManager manages environment-related operations
 */
export class EnvironmentManager {

    /** Creates a new EnvironmentManager instance. */
    constructor($$source: Partial<EnvironmentManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new EnvironmentManager instance from a string or object.
     */
    static createFrom($$source: any = {}): EnvironmentManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new EnvironmentManager($$parsedSource as Partial<EnvironmentManager>);
    }
}

/**
 * EventManager manages event-related operations
 */
export class EventManager {

    /** Creates a new EventManager instance. */
    constructor($$source: Partial<EventManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new EventManager instance from a string or object.
     */
    static createFrom($$source: any = {}): EventManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new EventManager($$parsedSource as Partial<EventManager>);
    }
}

/**
 * KeyBindingManager manages all key binding operations
 */
export class KeyBindingManager {

    /** Creates a new KeyBindingManager instance. */
    constructor($$source: Partial<KeyBindingManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new KeyBindingManager instance from a string or object.
     */
    static createFrom($$source: any = {}): KeyBindingManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new KeyBindingManager($$parsedSource as Partial<KeyBindingManager>);
    }
}

/**
 * LinuxWindow specific to Linux windows
 */
export class LinuxWindow {
    /**
     * Icon Sets up the icon representing the window. This icon is used when the window is minimized
     * (also known as iconified).
     */
    "Icon": string;

    /**
     * WindowIsTranslucent sets the window's background to transparent when enabled.
     */
    "WindowIsTranslucent": boolean;

    /**
     * WebviewGpuPolicy used for determining the hardware acceleration policy for the webview.
     *   - WebviewGpuPolicyAlways
     *   - WebviewGpuPolicyOnDemand
     *   - WebviewGpuPolicyNever
     * 
     * Due to https://github.com/wailsapp/wails/issues/2977, if options.Linux is nil
     * in the call to wails.Run(), WebviewGpuPolicy is set by default to WebviewGpuPolicyNever.
     * Client code may override this behavior by passing a non-nil Options and set
     * WebviewGpuPolicy as needed.
     */
    "WebviewGpuPolicy": WebviewGpuPolicy;

    /**
     * WindowDidMoveDebounceMS is the debounce time in milliseconds for the WindowDidMove event
     */
    "WindowDidMoveDebounceMS": number;

    /**
     * Menu is the window's menu
     */
    "Menu": Menu | null;

    /** Creates a new LinuxWindow instance. */
    constructor($$source: Partial<LinuxWindow> = {}) {
        if (!("Icon" in $$source)) {
            this["Icon"] = "";
        }
        if (!("WindowIsTranslucent" in $$source)) {
            this["WindowIsTranslucent"] = false;
        }
        if (!("WebviewGpuPolicy" in $$source)) {
            this["WebviewGpuPolicy"] = WebviewGpuPolicy.$zero;
        }
        if (!("WindowDidMoveDebounceMS" in $$source)) {
            this["WindowDidMoveDebounceMS"] = 0;
        }
        if (!("Menu" in $$source)) {
            this["Menu"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new LinuxWindow instance from a string or object.
     */
    static createFrom($$source: any = {}): LinuxWindow {
        const $$createField0_0 = $Create.ByteSlice;
        const $$createField4_0 = $$createType25;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Icon" in $$parsedSource) {
            $$parsedSource["Icon"] = $$createField0_0($$parsedSource["Icon"]);
        }
        if ("Menu" in $$parsedSource) {
            $$parsedSource["Menu"] = $$createField4_0($$parsedSource["Menu"]);
        }
        return new LinuxWindow($$parsedSource as Partial<LinuxWindow>);
    }
}

/**
 * MacAppearanceType is a type of Appearance for Cocoa windows
 */
export enum MacAppearanceType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    /**
     * DefaultAppearance uses the default system value
     */
    DefaultAppearance = "",

    /**
     * NSAppearanceNameAqua - The standard light system appearance.
     */
    NSAppearanceNameAqua = "NSAppearanceNameAqua",

    /**
     * NSAppearanceNameDarkAqua - The standard dark system appearance.
     */
    NSAppearanceNameDarkAqua = "NSAppearanceNameDarkAqua",

    /**
     * NSAppearanceNameVibrantLight - The light vibrant appearance
     */
    NSAppearanceNameVibrantLight = "NSAppearanceNameVibrantLight",

    /**
     * NSAppearanceNameAccessibilityHighContrastAqua - A high-contrast version of the standard light system appearance.
     */
    NSAppearanceNameAccessibilityHighContrastAqua = "NSAppearanceNameAccessibilityHighContrastAqua",

    /**
     * NSAppearanceNameAccessibilityHighContrastDarkAqua - A high-contrast version of the standard dark system appearance.
     */
    NSAppearanceNameAccessibilityHighContrastDarkAqua = "NSAppearanceNameAccessibilityHighContrastDarkAqua",

    /**
     * NSAppearanceNameAccessibilityHighContrastVibrantLight - A high-contrast version of the light vibrant appearance.
     */
    NSAppearanceNameAccessibilityHighContrastVibrantLight = "NSAppearanceNameAccessibilityHighContrastVibrantLight",

    /**
     * NSAppearanceNameAccessibilityHighContrastVibrantDark - A high-contrast version of the dark vibrant appearance.
     */
    NSAppearanceNameAccessibilityHighContrastVibrantDark = "NSAppearanceNameAccessibilityHighContrastVibrantDark",
};

/**
 * MacBackdrop is the backdrop type for macOS
 */
export enum MacBackdrop {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * MacBackdropNormal - The default value. The window will have a normal opaque background.
     */
    MacBackdropNormal = 0,

    /**
     * MacBackdropTransparent - The window will have a transparent background, with the content underneath it being visible
     */
    MacBackdropTransparent = 1,

    /**
     * MacBackdropTranslucent - The window will have a translucent background, with the content underneath it being "fuzzy" or "frosted"
     */
    MacBackdropTranslucent = 2,

    /**
     * MacBackdropLiquidGlass - The window will use Apple's Liquid Glass effect (macOS 15.0+ with fallback to translucent)
     */
    MacBackdropLiquidGlass = 3,
};

/**
 * MacLiquidGlass contains configuration for the Liquid Glass effect
 */
export class MacLiquidGlass {
    /**
     * Style of the glass effect
     */
    "Style": MacLiquidGlassStyle;

    /**
     * Material to use for NSVisualEffectView (when NSGlassEffectView is not available)
     * Set to NSVisualEffectMaterialAuto to use automatic selection based on Style
     */
    "Material": NSVisualEffectMaterial;

    /**
     * Corner radius for the glass effect (0 for square corners)
     */
    "CornerRadius": number;

    /**
     * Tint color for the glass (optional, nil for no tint)
     */
    "TintColor": RGBA | null;

    /**
     * Group identifier for merging multiple glass windows
     */
    "GroupID": string;

    /**
     * Spacing between grouped glass elements (in points)
     */
    "GroupSpacing": number;

    /** Creates a new MacLiquidGlass instance. */
    constructor($$source: Partial<MacLiquidGlass> = {}) {
        if (!("Style" in $$source)) {
            this["Style"] = MacLiquidGlassStyle.$zero;
        }
        if (!("Material" in $$source)) {
            this["Material"] = NSVisualEffectMaterial.$zero;
        }
        if (!("CornerRadius" in $$source)) {
            this["CornerRadius"] = 0;
        }
        if (!("TintColor" in $$source)) {
            this["TintColor"] = null;
        }
        if (!("GroupID" in $$source)) {
            this["GroupID"] = "";
        }
        if (!("GroupSpacing" in $$source)) {
            this["GroupSpacing"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacLiquidGlass instance from a string or object.
     */
    static createFrom($$source: any = {}): MacLiquidGlass {
        const $$createField3_0 = $$createType27;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TintColor" in $$parsedSource) {
            $$parsedSource["TintColor"] = $$createField3_0($$parsedSource["TintColor"]);
        }
        return new MacLiquidGlass($$parsedSource as Partial<MacLiquidGlass>);
    }
}

/**
 * MacLiquidGlassStyle defines the style of the Liquid Glass effect
 */
export enum MacLiquidGlassStyle {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * LiquidGlassStyleAutomatic - System determines the best style
     */
    LiquidGlassStyleAutomatic = 0,

    /**
     * LiquidGlassStyleLight - Light glass appearance
     */
    LiquidGlassStyleLight = 1,

    /**
     * LiquidGlassStyleDark - Dark glass appearance
     */
    LiquidGlassStyleDark = 2,

    /**
     * LiquidGlassStyleVibrant - Vibrant glass with enhanced effects
     */
    LiquidGlassStyleVibrant = 3,
};

/**
 * MacTitleBar contains options for the Mac titlebar
 */
export class MacTitleBar {
    /**
     * AppearsTransparent will make the titlebar transparent
     */
    "AppearsTransparent": boolean;

    /**
     * Hide will hide the titlebar
     */
    "Hide": boolean;

    /**
     * HideTitle will hide the title
     */
    "HideTitle": boolean;

    /**
     * FullSizeContent will extend the window content to the full size of the window
     */
    "FullSizeContent": boolean;

    /**
     * UseToolbar will use a toolbar instead of a titlebar
     */
    "UseToolbar": boolean;

    /**
     * HideToolbarSeparator will hide the toolbar separator
     */
    "HideToolbarSeparator": boolean;

    /**
     * ShowToolbarWhenFullscreen will keep the toolbar visible when the window is in fullscreen mode
     */
    "ShowToolbarWhenFullscreen": boolean;

    /**
     * ToolbarStyle is the style of toolbar to use
     */
    "ToolbarStyle": MacToolbarStyle;

    /** Creates a new MacTitleBar instance. */
    constructor($$source: Partial<MacTitleBar> = {}) {
        if (!("AppearsTransparent" in $$source)) {
            this["AppearsTransparent"] = false;
        }
        if (!("Hide" in $$source)) {
            this["Hide"] = false;
        }
        if (!("HideTitle" in $$source)) {
            this["HideTitle"] = false;
        }
        if (!("FullSizeContent" in $$source)) {
            this["FullSizeContent"] = false;
        }
        if (!("UseToolbar" in $$source)) {
            this["UseToolbar"] = false;
        }
        if (!("HideToolbarSeparator" in $$source)) {
            this["HideToolbarSeparator"] = false;
        }
        if (!("ShowToolbarWhenFullscreen" in $$source)) {
            this["ShowToolbarWhenFullscreen"] = false;
        }
        if (!("ToolbarStyle" in $$source)) {
            this["ToolbarStyle"] = MacToolbarStyle.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacTitleBar instance from a string or object.
     */
    static createFrom($$source: any = {}): MacTitleBar {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MacTitleBar($$parsedSource as Partial<MacTitleBar>);
    }
}

/**
 * MacToolbarStyle is the style of toolbar for macOS
 */
export enum MacToolbarStyle {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * MacToolbarStyleAutomatic - The default value. The style will be determined by the window's given configuration
     */
    MacToolbarStyleAutomatic = 0,

    /**
     * MacToolbarStyleExpanded - The toolbar will appear below the window title
     */
    MacToolbarStyleExpanded = 1,

    /**
     * MacToolbarStylePreference - The toolbar will appear below the window title and the items in the toolbar will attempt to have equal widths when possible
     */
    MacToolbarStylePreference = 2,

    /**
     * MacToolbarStyleUnified - The window title will appear inline with the toolbar when visible
     */
    MacToolbarStyleUnified = 3,

    /**
     * MacToolbarStyleUnifiedCompact - Same as MacToolbarStyleUnified, but with reduced margins in the toolbar allowing more focus to be on the contents of the window
     */
    MacToolbarStyleUnifiedCompact = 4,
};

/**
 * MacWebviewPreferences contains preferences for the Mac webview
 */
export class MacWebviewPreferences {
    /**
     * TabFocusesLinks will enable tabbing to links
     */
    "TabFocusesLinks": u$0.Bool;

    /**
     * TextInteractionEnabled will enable text interaction
     */
    "TextInteractionEnabled": u$0.Bool;

    /**
     * FullscreenEnabled will enable fullscreen
     */
    "FullscreenEnabled": u$0.Bool;

    /**
     * AllowsBackForwardNavigationGestures enables horizontal swipe gestures for back/forward navigation
     */
    "AllowsBackForwardNavigationGestures": u$0.Bool;

    /** Creates a new MacWebviewPreferences instance. */
    constructor($$source: Partial<MacWebviewPreferences> = {}) {
        if (!("TabFocusesLinks" in $$source)) {
            this["TabFocusesLinks"] = (new u$0.Bool());
        }
        if (!("TextInteractionEnabled" in $$source)) {
            this["TextInteractionEnabled"] = (new u$0.Bool());
        }
        if (!("FullscreenEnabled" in $$source)) {
            this["FullscreenEnabled"] = (new u$0.Bool());
        }
        if (!("AllowsBackForwardNavigationGestures" in $$source)) {
            this["AllowsBackForwardNavigationGestures"] = (new u$0.Bool());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacWebviewPreferences instance from a string or object.
     */
    static createFrom($$source: any = {}): MacWebviewPreferences {
        const $$createField0_0 = $$createType28;
        const $$createField1_0 = $$createType28;
        const $$createField2_0 = $$createType28;
        const $$createField3_0 = $$createType28;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TabFocusesLinks" in $$parsedSource) {
            $$parsedSource["TabFocusesLinks"] = $$createField0_0($$parsedSource["TabFocusesLinks"]);
        }
        if ("TextInteractionEnabled" in $$parsedSource) {
            $$parsedSource["TextInteractionEnabled"] = $$createField1_0($$parsedSource["TextInteractionEnabled"]);
        }
        if ("FullscreenEnabled" in $$parsedSource) {
            $$parsedSource["FullscreenEnabled"] = $$createField2_0($$parsedSource["FullscreenEnabled"]);
        }
        if ("AllowsBackForwardNavigationGestures" in $$parsedSource) {
            $$parsedSource["AllowsBackForwardNavigationGestures"] = $$createField3_0($$parsedSource["AllowsBackForwardNavigationGestures"]);
        }
        return new MacWebviewPreferences($$parsedSource as Partial<MacWebviewPreferences>);
    }
}

/**
 * MacWindow contains macOS specific options for Webview Windows
 */
export class MacWindow {
    /**
     * Backdrop is the backdrop type for the window
     */
    "Backdrop": MacBackdrop;

    /**
     * DisableShadow will disable the window shadow
     */
    "DisableShadow": boolean;

    /**
     * TitleBar contains options for the Mac titlebar
     */
    "TitleBar": MacTitleBar;

    /**
     * Appearance is the appearance type for the window
     */
    "Appearance": MacAppearanceType;

    /**
     * InvisibleTitleBarHeight defines the height of an invisible titlebar which responds to dragging
     */
    "InvisibleTitleBarHeight": number;

    /**
     * Maps events from platform specific to common event types
     */
    "EventMapping": { [_: `${number}`]: events$0.WindowEventType };

    /**
     * EnableFraudulentWebsiteWarnings will enable warnings for fraudulent websites.
     * Default: false
     */
    "EnableFraudulentWebsiteWarnings": boolean;

    /**
     * WebviewPreferences contains preferences for the webview
     */
    "WebviewPreferences": MacWebviewPreferences;

    /**
     * WindowLevel sets the window level to control the order of windows in the screen
     */
    "WindowLevel": MacWindowLevel;

    /**
     * LiquidGlass contains configuration for the Liquid Glass effect
     */
    "LiquidGlass": MacLiquidGlass;

    /** Creates a new MacWindow instance. */
    constructor($$source: Partial<MacWindow> = {}) {
        if (!("Backdrop" in $$source)) {
            this["Backdrop"] = MacBackdrop.$zero;
        }
        if (!("DisableShadow" in $$source)) {
            this["DisableShadow"] = false;
        }
        if (!("TitleBar" in $$source)) {
            this["TitleBar"] = (new MacTitleBar());
        }
        if (!("Appearance" in $$source)) {
            this["Appearance"] = MacAppearanceType.$zero;
        }
        if (!("InvisibleTitleBarHeight" in $$source)) {
            this["InvisibleTitleBarHeight"] = 0;
        }
        if (!("EventMapping" in $$source)) {
            this["EventMapping"] = {};
        }
        if (!("EnableFraudulentWebsiteWarnings" in $$source)) {
            this["EnableFraudulentWebsiteWarnings"] = false;
        }
        if (!("WebviewPreferences" in $$source)) {
            this["WebviewPreferences"] = (new MacWebviewPreferences());
        }
        if (!("WindowLevel" in $$source)) {
            this["WindowLevel"] = MacWindowLevel.$zero;
        }
        if (!("LiquidGlass" in $$source)) {
            this["LiquidGlass"] = (new MacLiquidGlass());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MacWindow instance from a string or object.
     */
    static createFrom($$source: any = {}): MacWindow {
        const $$createField2_0 = $$createType29;
        const $$createField5_0 = $$createType30;
        const $$createField7_0 = $$createType31;
        const $$createField9_0 = $$createType32;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TitleBar" in $$parsedSource) {
            $$parsedSource["TitleBar"] = $$createField2_0($$parsedSource["TitleBar"]);
        }
        if ("EventMapping" in $$parsedSource) {
            $$parsedSource["EventMapping"] = $$createField5_0($$parsedSource["EventMapping"]);
        }
        if ("WebviewPreferences" in $$parsedSource) {
            $$parsedSource["WebviewPreferences"] = $$createField7_0($$parsedSource["WebviewPreferences"]);
        }
        if ("LiquidGlass" in $$parsedSource) {
            $$parsedSource["LiquidGlass"] = $$createField9_0($$parsedSource["LiquidGlass"]);
        }
        return new MacWindow($$parsedSource as Partial<MacWindow>);
    }
}

export enum MacWindowLevel {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    MacWindowLevelNormal = "normal",
    MacWindowLevelFloating = "floating",
    MacWindowLevelTornOffMenu = "tornOffMenu",
    MacWindowLevelModalPanel = "modalPanel",
    MacWindowLevelMainMenu = "mainMenu",
    MacWindowLevelStatus = "status",
    MacWindowLevelPopUpMenu = "popUpMenu",
    MacWindowLevelScreenSaver = "screenSaver",
};

export class Menu {

    /** Creates a new Menu instance. */
    constructor($$source: Partial<Menu> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Menu instance from a string or object.
     */
    static createFrom($$source: any = {}): Menu {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Menu($$parsedSource as Partial<Menu>);
    }
}

export class MenuBarTheme {
    /**
     * Default is the default theme
     */
    "Default": TextTheme | null;

    /**
     * Hover defines the theme to use when the menu item is hovered
     */
    "Hover": TextTheme | null;

    /**
     * Selected defines the theme to use when the menu item is selected
     */
    "Selected": TextTheme | null;

    /** Creates a new MenuBarTheme instance. */
    constructor($$source: Partial<MenuBarTheme> = {}) {
        if (!("Default" in $$source)) {
            this["Default"] = null;
        }
        if (!("Hover" in $$source)) {
            this["Hover"] = null;
        }
        if (!("Selected" in $$source)) {
            this["Selected"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MenuBarTheme instance from a string or object.
     */
    static createFrom($$source: any = {}): MenuBarTheme {
        const $$createField0_0 = $$createType34;
        const $$createField1_0 = $$createType34;
        const $$createField2_0 = $$createType34;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Default" in $$parsedSource) {
            $$parsedSource["Default"] = $$createField0_0($$parsedSource["Default"]);
        }
        if ("Hover" in $$parsedSource) {
            $$parsedSource["Hover"] = $$createField1_0($$parsedSource["Hover"]);
        }
        if ("Selected" in $$parsedSource) {
            $$parsedSource["Selected"] = $$createField2_0($$parsedSource["Selected"]);
        }
        return new MenuBarTheme($$parsedSource as Partial<MenuBarTheme>);
    }
}

/**
 * MenuManager manages menu-related operations
 */
export class MenuManager {

    /** Creates a new MenuManager instance. */
    constructor($$source: Partial<MenuManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MenuManager instance from a string or object.
     */
    static createFrom($$source: any = {}): MenuManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MenuManager($$parsedSource as Partial<MenuManager>);
    }
}

/**
 * NSVisualEffectMaterial represents the NSVisualEffectMaterial enum for macOS
 */
export enum NSVisualEffectMaterial {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * NSVisualEffectMaterial values from macOS SDK
     */
    NSVisualEffectMaterialAppearanceBased = 0,
    NSVisualEffectMaterialLight = 1,
    NSVisualEffectMaterialDark = 2,
    NSVisualEffectMaterialTitlebar = 3,
    NSVisualEffectMaterialSelection = 4,
    NSVisualEffectMaterialMenu = 5,
    NSVisualEffectMaterialPopover = 6,
    NSVisualEffectMaterialSidebar = 7,
    NSVisualEffectMaterialHeaderView = 10,
    NSVisualEffectMaterialSheet = 11,
    NSVisualEffectMaterialWindowBackground = 12,
    NSVisualEffectMaterialHUDWindow = 13,
    NSVisualEffectMaterialFullScreenUI = 15,
    NSVisualEffectMaterialToolTip = 17,
    NSVisualEffectMaterialContentBackground = 18,
    NSVisualEffectMaterialUnderWindowBackground = 21,
    NSVisualEffectMaterialUnderPageBackground = 22,

    /**
     * Use auto-selection based on Style
     */
    NSVisualEffectMaterialAuto = -1,
};

export class RGBA {
    "Red": number;
    "Green": number;
    "Blue": number;
    "Alpha": number;

    /** Creates a new RGBA instance. */
    constructor($$source: Partial<RGBA> = {}) {
        if (!("Red" in $$source)) {
            this["Red"] = 0;
        }
        if (!("Green" in $$source)) {
            this["Green"] = 0;
        }
        if (!("Blue" in $$source)) {
            this["Blue"] = 0;
        }
        if (!("Alpha" in $$source)) {
            this["Alpha"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RGBA instance from a string or object.
     */
    static createFrom($$source: any = {}): RGBA {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new RGBA($$parsedSource as Partial<RGBA>);
    }
}

export class ScreenManager {

    /** Creates a new ScreenManager instance. */
    constructor($$source: Partial<ScreenManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ScreenManager instance from a string or object.
     */
    static createFrom($$source: any = {}): ScreenManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ScreenManager($$parsedSource as Partial<ScreenManager>);
    }
}

/**
 * SystemTrayManager manages system tray-related operations
 */
export class SystemTrayManager {

    /** Creates a new SystemTrayManager instance. */
    constructor($$source: Partial<SystemTrayManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new SystemTrayManager instance from a string or object.
     */
    static createFrom($$source: any = {}): SystemTrayManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new SystemTrayManager($$parsedSource as Partial<SystemTrayManager>);
    }
}

export class TextTheme {
    /**
     * Text is the colour of the text
     */
    "Text": number | null;

    /**
     * Background is the background colour of the text
     */
    "Background": number | null;

    /** Creates a new TextTheme instance. */
    constructor($$source: Partial<TextTheme> = {}) {
        if (!("Text" in $$source)) {
            this["Text"] = null;
        }
        if (!("Background" in $$source)) {
            this["Background"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TextTheme instance from a string or object.
     */
    static createFrom($$source: any = {}): TextTheme {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TextTheme($$parsedSource as Partial<TextTheme>);
    }
}

export enum Theme {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * SystemDefault will use whatever the system theme is. The application will follow system theme changes.
     */
    SystemDefault = 0,

    /**
     * Dark Mode
     */
    Dark = 1,

    /**
     * Light Mode
     */
    Light = 2,
};

/**
 * ThemeSettings defines custom colours to use in dark or light mode.
 * They may be set using the hex values: 0x00BBGGRR
 */
export class ThemeSettings {
    /**
     * Dark mode active window
     */
    "DarkModeActive": WindowTheme | null;

    /**
     * Dark mode inactive window
     */
    "DarkModeInactive": WindowTheme | null;

    /**
     * Light mode active window
     */
    "LightModeActive": WindowTheme | null;

    /**
     * Light mode inactive window
     */
    "LightModeInactive": WindowTheme | null;

    /**
     * Dark mode MenuBar
     */
    "DarkModeMenuBar": MenuBarTheme | null;

    /**
     * Light mode MenuBar
     */
    "LightModeMenuBar": MenuBarTheme | null;

    /** Creates a new ThemeSettings instance. */
    constructor($$source: Partial<ThemeSettings> = {}) {
        if (!("DarkModeActive" in $$source)) {
            this["DarkModeActive"] = null;
        }
        if (!("DarkModeInactive" in $$source)) {
            this["DarkModeInactive"] = null;
        }
        if (!("LightModeActive" in $$source)) {
            this["LightModeActive"] = null;
        }
        if (!("LightModeInactive" in $$source)) {
            this["LightModeInactive"] = null;
        }
        if (!("DarkModeMenuBar" in $$source)) {
            this["DarkModeMenuBar"] = null;
        }
        if (!("LightModeMenuBar" in $$source)) {
            this["LightModeMenuBar"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ThemeSettings instance from a string or object.
     */
    static createFrom($$source: any = {}): ThemeSettings {
        const $$createField0_0 = $$createType36;
        const $$createField1_0 = $$createType36;
        const $$createField2_0 = $$createType36;
        const $$createField3_0 = $$createType36;
        const $$createField4_0 = $$createType38;
        const $$createField5_0 = $$createType38;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("DarkModeActive" in $$parsedSource) {
            $$parsedSource["DarkModeActive"] = $$createField0_0($$parsedSource["DarkModeActive"]);
        }
        if ("DarkModeInactive" in $$parsedSource) {
            $$parsedSource["DarkModeInactive"] = $$createField1_0($$parsedSource["DarkModeInactive"]);
        }
        if ("LightModeActive" in $$parsedSource) {
            $$parsedSource["LightModeActive"] = $$createField2_0($$parsedSource["LightModeActive"]);
        }
        if ("LightModeInactive" in $$parsedSource) {
            $$parsedSource["LightModeInactive"] = $$createField3_0($$parsedSource["LightModeInactive"]);
        }
        if ("DarkModeMenuBar" in $$parsedSource) {
            $$parsedSource["DarkModeMenuBar"] = $$createField4_0($$parsedSource["DarkModeMenuBar"]);
        }
        if ("LightModeMenuBar" in $$parsedSource) {
            $$parsedSource["LightModeMenuBar"] = $$createField5_0($$parsedSource["LightModeMenuBar"]);
        }
        return new ThemeSettings($$parsedSource as Partial<ThemeSettings>);
    }
}

/**
 * WebviewGpuPolicy values used for determining the webview's hardware acceleration policy.
 */
export enum WebviewGpuPolicy {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * WebviewGpuPolicyAlways Hardware acceleration is always enabled.
     */
    WebviewGpuPolicyAlways = 0,

    /**
     * WebviewGpuPolicyOnDemand Hardware acceleration is enabled/disabled as request by web contents.
     */
    WebviewGpuPolicyOnDemand = 1,

    /**
     * WebviewGpuPolicyNever Hardware acceleration is always disabled.
     */
    WebviewGpuPolicyNever = 2,
};

export class WebviewWindowOptions {
    /**
     * Name is a unique identifier that can be given to a window.
     */
    "Name": string;

    /**
     * Title is the title of the window.
     */
    "Title": string;

    /**
     * Width is the starting width of the window.
     */
    "Width": number;

    /**
     * Height is the starting height of the window.
     */
    "Height": number;

    /**
     * AlwaysOnTop will make the window float above other windows.
     */
    "AlwaysOnTop": boolean;

    /**
     * URL is the URL to load in the window.
     */
    "URL": string;

    /**
     * DisableResize will disable the ability to resize the window.
     */
    "DisableResize": boolean;

    /**
     * Frameless will remove the window frame.
     */
    "Frameless": boolean;

    /**
     * MinWidth is the minimum width of the window.
     */
    "MinWidth": number;

    /**
     * MinHeight is the minimum height of the window.
     */
    "MinHeight": number;

    /**
     * MaxWidth is the maximum width of the window.
     */
    "MaxWidth": number;

    /**
     * MaxHeight is the maximum height of the window.
     */
    "MaxHeight": number;

    /**
     * StartState indicates the state of the window when it is first shown.
     * Default: WindowStateNormal
     */
    "StartState": WindowState;

    /**
     * BackgroundType is the type of background to use for the window.
     * Default: BackgroundTypeSolid
     */
    "BackgroundType": BackgroundType;

    /**
     * BackgroundColour is the colour to use for the window background.
     */
    "BackgroundColour": RGBA;

    /**
     * HTML is the HTML to load in the window.
     */
    "HTML": string;

    /**
     * JS is the JavaScript to load in the window.
     */
    "JS": string;

    /**
     * CSS is the CSS to load in the window.
     */
    "CSS": string;

    /**
     * Initial Position
     */
    "InitialPosition": WindowStartPosition;

    /**
     * X is the starting X position of the window.
     */
    "X": number;

    /**
     * Y is the starting Y position of the window.
     */
    "Y": number;

    /**
     * Hidden will hide the window when it is first created.
     */
    "Hidden": boolean;

    /**
     * Zoom is the zoom level of the window.
     */
    "Zoom": number;

    /**
     * ZoomControlEnabled will enable the zoom control.
     */
    "ZoomControlEnabled": boolean;

    /**
     * EnableDragAndDrop will enable drag and drop.
     */
    "EnableDragAndDrop": boolean;

    /**
     * OpenInspectorOnStartup will open the inspector when the window is first shown.
     */
    "OpenInspectorOnStartup": boolean;

    /**
     * Mac options
     */
    "Mac": MacWindow;

    /**
     * Windows options
     */
    "Windows": WindowsWindow;

    /**
     * Linux options
     */
    "Linux": LinuxWindow;

    /**
     * Toolbar button states
     */
    "MinimiseButtonState": ButtonState;
    "MaximiseButtonState": ButtonState;
    "CloseButtonState": ButtonState;

    /**
     * If true, the window's devtools will be available (default true in builds without the `production` build tag)
     */
    "DevToolsEnabled": boolean;

    /**
     * If true, the window's default context menu will be disabled (default false)
     */
    "DefaultContextMenuDisabled": boolean;

    /**
     * KeyBindings is a map of key bindings to functions
     */
    "KeyBindings": { [_: string]: any };

    /**
     * IgnoreMouseEvents will ignore mouse events in the window (Windows + Mac only)
     */
    "IgnoreMouseEvents": boolean;

    /**
     * ContentProtectionEnabled specifies whether content protection is enabled, preventing screen capture and recording.
     * Effective on Windows and macOS only; no-op on Linux.
     * Best-effort protection with platform-specific caveats (see docs).
     */
    "ContentProtectionEnabled": boolean;

    /** Creates a new WebviewWindowOptions instance. */
    constructor($$source: Partial<WebviewWindowOptions> = {}) {
        if (!("Name" in $$source)) {
            this["Name"] = "";
        }
        if (!("Title" in $$source)) {
            this["Title"] = "";
        }
        if (!("Width" in $$source)) {
            this["Width"] = 0;
        }
        if (!("Height" in $$source)) {
            this["Height"] = 0;
        }
        if (!("AlwaysOnTop" in $$source)) {
            this["AlwaysOnTop"] = false;
        }
        if (!("URL" in $$source)) {
            this["URL"] = "";
        }
        if (!("DisableResize" in $$source)) {
            this["DisableResize"] = false;
        }
        if (!("Frameless" in $$source)) {
            this["Frameless"] = false;
        }
        if (!("MinWidth" in $$source)) {
            this["MinWidth"] = 0;
        }
        if (!("MinHeight" in $$source)) {
            this["MinHeight"] = 0;
        }
        if (!("MaxWidth" in $$source)) {
            this["MaxWidth"] = 0;
        }
        if (!("MaxHeight" in $$source)) {
            this["MaxHeight"] = 0;
        }
        if (!("StartState" in $$source)) {
            this["StartState"] = WindowState.$zero;
        }
        if (!("BackgroundType" in $$source)) {
            this["BackgroundType"] = BackgroundType.$zero;
        }
        if (!("BackgroundColour" in $$source)) {
            this["BackgroundColour"] = (new RGBA());
        }
        if (!("HTML" in $$source)) {
            this["HTML"] = "";
        }
        if (!("JS" in $$source)) {
            this["JS"] = "";
        }
        if (!("CSS" in $$source)) {
            this["CSS"] = "";
        }
        if (!("InitialPosition" in $$source)) {
            this["InitialPosition"] = WindowStartPosition.$zero;
        }
        if (!("X" in $$source)) {
            this["X"] = 0;
        }
        if (!("Y" in $$source)) {
            this["Y"] = 0;
        }
        if (!("Hidden" in $$source)) {
            this["Hidden"] = false;
        }
        if (!("Zoom" in $$source)) {
            this["Zoom"] = 0;
        }
        if (!("ZoomControlEnabled" in $$source)) {
            this["ZoomControlEnabled"] = false;
        }
        if (!("EnableDragAndDrop" in $$source)) {
            this["EnableDragAndDrop"] = false;
        }
        if (!("OpenInspectorOnStartup" in $$source)) {
            this["OpenInspectorOnStartup"] = false;
        }
        if (!("Mac" in $$source)) {
            this["Mac"] = (new MacWindow());
        }
        if (!("Windows" in $$source)) {
            this["Windows"] = (new WindowsWindow());
        }
        if (!("Linux" in $$source)) {
            this["Linux"] = (new LinuxWindow());
        }
        if (!("MinimiseButtonState" in $$source)) {
            this["MinimiseButtonState"] = ButtonState.$zero;
        }
        if (!("MaximiseButtonState" in $$source)) {
            this["MaximiseButtonState"] = ButtonState.$zero;
        }
        if (!("CloseButtonState" in $$source)) {
            this["CloseButtonState"] = ButtonState.$zero;
        }
        if (!("DevToolsEnabled" in $$source)) {
            this["DevToolsEnabled"] = false;
        }
        if (!("DefaultContextMenuDisabled" in $$source)) {
            this["DefaultContextMenuDisabled"] = false;
        }
        if (!("KeyBindings" in $$source)) {
            this["KeyBindings"] = {};
        }
        if (!("IgnoreMouseEvents" in $$source)) {
            this["IgnoreMouseEvents"] = false;
        }
        if (!("ContentProtectionEnabled" in $$source)) {
            this["ContentProtectionEnabled"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WebviewWindowOptions instance from a string or object.
     */
    static createFrom($$source: any = {}): WebviewWindowOptions {
        const $$createField14_0 = $$createType26;
        const $$createField26_0 = $$createType39;
        const $$createField27_0 = $$createType40;
        const $$createField28_0 = $$createType41;
        const $$createField34_0 = $$createType42;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("BackgroundColour" in $$parsedSource) {
            $$parsedSource["BackgroundColour"] = $$createField14_0($$parsedSource["BackgroundColour"]);
        }
        if ("Mac" in $$parsedSource) {
            $$parsedSource["Mac"] = $$createField26_0($$parsedSource["Mac"]);
        }
        if ("Windows" in $$parsedSource) {
            $$parsedSource["Windows"] = $$createField27_0($$parsedSource["Windows"]);
        }
        if ("Linux" in $$parsedSource) {
            $$parsedSource["Linux"] = $$createField28_0($$parsedSource["Linux"]);
        }
        if ("KeyBindings" in $$parsedSource) {
            $$parsedSource["KeyBindings"] = $$createField34_0($$parsedSource["KeyBindings"]);
        }
        return new WebviewWindowOptions($$parsedSource as Partial<WebviewWindowOptions>);
    }
}

/**
 * WindowManager manages all window-related operations
 */
export class WindowManager {

    /** Creates a new WindowManager instance. */
    constructor($$source: Partial<WindowManager> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowManager instance from a string or object.
     */
    static createFrom($$source: any = {}): WindowManager {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WindowManager($$parsedSource as Partial<WindowManager>);
    }
}

export enum WindowStartPosition {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    WindowCentered = 0,
    WindowXY = 1,
};

export enum WindowState {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    WindowStateNormal = 0,
    WindowStateMinimised = 1,
    WindowStateMaximised = 2,
    WindowStateFullscreen = 3,
};

export class WindowTheme {
    /**
     * BorderColour is the colour of the window border
     */
    "BorderColour": number | null;

    /**
     * TitleBarColour is the colour of the window title bar
     */
    "TitleBarColour": number | null;

    /**
     * TitleTextColour is the colour of the window title text
     */
    "TitleTextColour": number | null;

    /** Creates a new WindowTheme instance. */
    constructor($$source: Partial<WindowTheme> = {}) {
        if (!("BorderColour" in $$source)) {
            this["BorderColour"] = null;
        }
        if (!("TitleBarColour" in $$source)) {
            this["TitleBarColour"] = null;
        }
        if (!("TitleTextColour" in $$source)) {
            this["TitleTextColour"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowTheme instance from a string or object.
     */
    static createFrom($$source: any = {}): WindowTheme {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new WindowTheme($$parsedSource as Partial<WindowTheme>);
    }
}

export class WindowsWindow {
    /**
     * Select the type of translucent backdrop. Requires Windows 11 22621 or later.
     * Only used when window's `BackgroundType` is set to `BackgroundTypeTranslucent`.
     * Default: Auto
     */
    "BackdropType": BackdropType;

    /**
     * Disable the icon in the titlebar
     * Default: false
     */
    "DisableIcon": boolean;

    /**
     * Theme (Dark / Light / SystemDefault)
     * Default: SystemDefault - The application will follow system theme changes.
     */
    "Theme": Theme;

    /**
     * Specify custom colours to use for dark/light mode
     * Default: nil
     */
    "CustomTheme": ThemeSettings;

    /**
     * Disable all window decorations in Frameless mode, which means no "Aero Shadow" and no "Rounded Corner" will be shown.
     * "Rounded Corners" are only available on Windows 11.
     * Default: false
     */
    "DisableFramelessWindowDecorations": boolean;

    /**
     * WindowMask is used to set the window shape. Use a PNG with an alpha channel to create a custom shape.
     * Default: nil
     */
    "WindowMask": string;

    /**
     * WindowMaskDraggable is used to make the window draggable by clicking on the window mask.
     * Default: false
     */
    "WindowMaskDraggable": boolean;

    /**
     * ResizeDebounceMS is the amount of time to debounce redraws of webview2
     * when resizing the window
     * Default: 0
     */
    "ResizeDebounceMS": number;

    /**
     * WindowDidMoveDebounceMS is the amount of time to debounce the WindowDidMove event
     * when moving the window
     * Default: 0
     */
    "WindowDidMoveDebounceMS": number;

    /**
     * Event mapping for the window. This allows you to define a translation from one event to another.
     * Default: nil
     */
    "EventMapping": { [_: `${number}`]: events$0.WindowEventType };

    /**
     * HiddenOnTaskbar hides the window from the taskbar
     * Default: false
     */
    "HiddenOnTaskbar": boolean;

    /**
     * EnableSwipeGestures enables swipe gestures for the window
     * Default: false
     */
    "EnableSwipeGestures": boolean;

    /**
     * Menu is the menu to use for the window.
     */
    "Menu": Menu | null;

    /**
     * Drag Cursor Effects
     */
    "OnEnterEffect": DragEffect;
    "OnOverEffect": DragEffect;

    /**
     * Permissions map for WebView2. If empty, default permissions will be granted.
     */
    "Permissions": { [_: `${number}`]: CoreWebView2PermissionState };

    /**
     * ExStyle is the extended window style
     */
    "ExStyle": number;

    /**
     * GeneralAutofillEnabled enables general autofill
     */
    "GeneralAutofillEnabled": boolean;

    /**
     * PasswordAutosaveEnabled enables autosaving passwords
     */
    "PasswordAutosaveEnabled": boolean;

    /**
     * EnabledFeatures, DisabledFeatures and AdditionalLaunchArgs are used to enable or disable specific features in the WebView2 browser.
     * Available flags: https://learn.microsoft.com/en-us/microsoft-edge/webview2/concepts/webview-features-flags?tabs=dotnetcsharp#available-webview2-browser-flags
     * WARNING: Apps in production shouldn't use WebView2 browser flags,
     * because these flags might be removed or altered at any time,
     * and aren't necessarily supported long-term.
     * AdditionalLaunchArgs should always be preceded by "--"
     */
    "EnabledFeatures": string[];
    "DisabledFeatures": string[];
    "AdditionalLaunchArgs": string[];

    /** Creates a new WindowsWindow instance. */
    constructor($$source: Partial<WindowsWindow> = {}) {
        if (!("BackdropType" in $$source)) {
            this["BackdropType"] = BackdropType.$zero;
        }
        if (!("DisableIcon" in $$source)) {
            this["DisableIcon"] = false;
        }
        if (!("Theme" in $$source)) {
            this["Theme"] = Theme.$zero;
        }
        if (!("CustomTheme" in $$source)) {
            this["CustomTheme"] = (new ThemeSettings());
        }
        if (!("DisableFramelessWindowDecorations" in $$source)) {
            this["DisableFramelessWindowDecorations"] = false;
        }
        if (!("WindowMask" in $$source)) {
            this["WindowMask"] = "";
        }
        if (!("WindowMaskDraggable" in $$source)) {
            this["WindowMaskDraggable"] = false;
        }
        if (!("ResizeDebounceMS" in $$source)) {
            this["ResizeDebounceMS"] = 0;
        }
        if (!("WindowDidMoveDebounceMS" in $$source)) {
            this["WindowDidMoveDebounceMS"] = 0;
        }
        if (!("EventMapping" in $$source)) {
            this["EventMapping"] = {};
        }
        if (!("HiddenOnTaskbar" in $$source)) {
            this["HiddenOnTaskbar"] = false;
        }
        if (!("EnableSwipeGestures" in $$source)) {
            this["EnableSwipeGestures"] = false;
        }
        if (!("Menu" in $$source)) {
            this["Menu"] = null;
        }
        if (!("OnEnterEffect" in $$source)) {
            this["OnEnterEffect"] = DragEffect.$zero;
        }
        if (!("OnOverEffect" in $$source)) {
            this["OnOverEffect"] = DragEffect.$zero;
        }
        if (!("Permissions" in $$source)) {
            this["Permissions"] = {};
        }
        if (!("ExStyle" in $$source)) {
            this["ExStyle"] = 0;
        }
        if (!("GeneralAutofillEnabled" in $$source)) {
            this["GeneralAutofillEnabled"] = false;
        }
        if (!("PasswordAutosaveEnabled" in $$source)) {
            this["PasswordAutosaveEnabled"] = false;
        }
        if (!("EnabledFeatures" in $$source)) {
            this["EnabledFeatures"] = [];
        }
        if (!("DisabledFeatures" in $$source)) {
            this["DisabledFeatures"] = [];
        }
        if (!("AdditionalLaunchArgs" in $$source)) {
            this["AdditionalLaunchArgs"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new WindowsWindow instance from a string or object.
     */
    static createFrom($$source: any = {}): WindowsWindow {
        const $$createField3_0 = $$createType43;
        const $$createField5_0 = $Create.ByteSlice;
        const $$createField9_0 = $$createType30;
        const $$createField12_0 = $$createType25;
        const $$createField15_0 = $$createType44;
        const $$createField19_0 = $$createType45;
        const $$createField20_0 = $$createType45;
        const $$createField21_0 = $$createType45;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("CustomTheme" in $$parsedSource) {
            $$parsedSource["CustomTheme"] = $$createField3_0($$parsedSource["CustomTheme"]);
        }
        if ("WindowMask" in $$parsedSource) {
            $$parsedSource["WindowMask"] = $$createField5_0($$parsedSource["WindowMask"]);
        }
        if ("EventMapping" in $$parsedSource) {
            $$parsedSource["EventMapping"] = $$createField9_0($$parsedSource["EventMapping"]);
        }
        if ("Menu" in $$parsedSource) {
            $$parsedSource["Menu"] = $$createField12_0($$parsedSource["Menu"]);
        }
        if ("Permissions" in $$parsedSource) {
            $$parsedSource["Permissions"] = $$createField15_0($$parsedSource["Permissions"]);
        }
        if ("EnabledFeatures" in $$parsedSource) {
            $$parsedSource["EnabledFeatures"] = $$createField19_0($$parsedSource["EnabledFeatures"]);
        }
        if ("DisabledFeatures" in $$parsedSource) {
            $$parsedSource["DisabledFeatures"] = $$createField20_0($$parsedSource["DisabledFeatures"]);
        }
        if ("AdditionalLaunchArgs" in $$parsedSource) {
            $$parsedSource["AdditionalLaunchArgs"] = $$createField21_0($$parsedSource["AdditionalLaunchArgs"]);
        }
        return new WindowsWindow($$parsedSource as Partial<WindowsWindow>);
    }
}

// Private type creation functions
const $$createType0 = WindowManager.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
const $$createType2 = ContextMenuManager.createFrom;
const $$createType3 = $Create.Nullable($$createType2);
const $$createType4 = KeyBindingManager.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
const $$createType6 = BrowserManager.createFrom;
const $$createType7 = $Create.Nullable($$createType6);
const $$createType8 = EnvironmentManager.createFrom;
const $$createType9 = $Create.Nullable($$createType8);
const $$createType10 = DialogManager.createFrom;
const $$createType11 = $Create.Nullable($$createType10);
const $$createType12 = EventManager.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
const $$createType14 = MenuManager.createFrom;
const $$createType15 = $Create.Nullable($$createType14);
const $$createType16 = ScreenManager.createFrom;
const $$createType17 = $Create.Nullable($$createType16);
const $$createType18 = ClipboardManager.createFrom;
const $$createType19 = $Create.Nullable($$createType18);
const $$createType20 = SystemTrayManager.createFrom;
const $$createType21 = $Create.Nullable($$createType20);
const $$createType22 = slog$0.Logger.createFrom;
const $$createType23 = $Create.Nullable($$createType22);
const $$createType24 = Menu.createFrom;
const $$createType25 = $Create.Nullable($$createType24);
const $$createType26 = RGBA.createFrom;
const $$createType27 = $Create.Nullable($$createType26);
const $$createType28 = u$0.Var.createFrom($Create.Any);
const $$createType29 = MacTitleBar.createFrom;
const $$createType30 = $Create.Map($Create.Any, $Create.Any);
const $$createType31 = MacWebviewPreferences.createFrom;
const $$createType32 = MacLiquidGlass.createFrom;
const $$createType33 = TextTheme.createFrom;
const $$createType34 = $Create.Nullable($$createType33);
const $$createType35 = WindowTheme.createFrom;
const $$createType36 = $Create.Nullable($$createType35);
const $$createType37 = MenuBarTheme.createFrom;
const $$createType38 = $Create.Nullable($$createType37);
const $$createType39 = MacWindow.createFrom;
const $$createType40 = WindowsWindow.createFrom;
const $$createType41 = LinuxWindow.createFrom;
const $$createType42 = $Create.Map($Create.Any, $Create.Any);
const $$createType43 = ThemeSettings.createFrom;
const $$createType44 = $Create.Map($Create.Any, $Create.Any);
const $$createType45 = $Create.Array($Create.Any);
